#!/usr/bin/env python3
"""
Data Lineage Module - Track generator and validator versions for training data.

This module provides:
1. Generator registry - known generators with their versions
2. FileLineage dataclass - metadata for a training file
3. Utilities to read/write .meta.json sidecar files

Every training file can have an associated .meta.json sidecar that tracks:
- Which generator produced it
- Which version of the generator
- When it was generated
- Generation parameters

Example:
    train_SYLLO_level3_100_20251126.jsonl
    train_SYLLO_level3_100_20251126.jsonl.meta.json  # sidecar

Usage:
    from core.lineage import FileLineage, write_file_lineage, read_file_lineage

    # When generating data
    lineage = FileLineage(
        generator_id="syllo_api",
        generator_version="1.0.0",
        params={"level": 3, "count": 100}
    )
    write_file_lineage(output_path, lineage)

    # When validating/training
    lineage = read_file_lineage(data_path)
    if lineage:
        print(f"Generated by {lineage.generator_id}@{lineage.generator_version}")
"""

import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)


# =============================================================================
# GENERATOR REGISTRY
# =============================================================================
# Central registry of known generators. Used for:
# - Validating generator_id values
# - Providing default versions when not specified
# - Documentation of data sources

GENERATOR_REGISTRY: Dict[str, Dict[str, Any]] = {
    "discrimination": {
        "version": "1.0.0",
        "source": "monitoring/discrimination_generator.py",
        "description": "Discrimination + correction training data",
    },
    "syllo_local": {
        "version": "1.0.0",
        "source": "data_manager/generators/syllogism_generator.py",
        "description": "Local syllogism generation via export script",
    },
    "syllo_api": {
        "version": "1.0.0",
        "source": "singleSKILL SYLLO API (localhost:8080)",
        "description": "Remote SYLLO API generation",
    },
    "curriculum": {
        "version": "1.0.0",
        "source": "data_manager/curriculum_manager.py",
        "description": "Curriculum-driven adaptive generation",
    },
    "manual": {
        "version": "1.0.0",
        "source": "human",
        "description": "Manually created or external data",
    },
    "bin_api": {
        "version": "1.0.0",
        "source": "singleSKILL Binary API (localhost:8090)",
        "description": "Binary arithmetic training via Bin API",
    },
}


# =============================================================================
# FILE LINEAGE DATACLASS
# =============================================================================

@dataclass
class FileLineage:
    """
    Metadata about a training file's origin.

    Stored as .meta.json sidecar alongside the training JSONL file.
    """
    # Required: which generator produced this file
    generator_id: str
    generator_version: str

    # When was this file generated
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    # How many examples in the file
    example_count: Optional[int] = None

    # Generator-specific parameters (level, difficulty, etc.)
    params: Dict[str, Any] = field(default_factory=dict)

    # Validation results (populated after validation)
    validated_at: Optional[str] = None
    validator_versions: Dict[str, str] = field(default_factory=dict)
    validation_passed: Optional[bool] = None
    validation_errors: int = 0
    validation_warnings: int = 0

    # Optional: source file or API endpoint
    source: Optional[str] = None

    # Optional: extra metadata
    extra: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'FileLineage':
        """Create from dictionary."""
        # Handle unknown fields gracefully
        known_fields = {f.name for f in cls.__dataclass_fields__.values()}
        filtered = {k: v for k, v in data.items() if k in known_fields}
        return cls(**filtered)

    def update_validation(
        self,
        validator_name: str,
        validator_version: str,
        passed: bool,
        errors: int = 0,
        warnings: int = 0
    ):
        """Update with validation results."""
        self.validated_at = datetime.now().isoformat()
        self.validator_versions[validator_name] = validator_version
        self.validation_passed = passed
        self.validation_errors = errors
        self.validation_warnings = warnings


# =============================================================================
# FILE I/O UTILITIES
# =============================================================================

def get_meta_path(data_path: Path) -> Path:
    """Get the .meta.json sidecar path for a data file."""
    return Path(str(data_path) + ".meta.json")


def write_file_lineage(data_path: Path, lineage: FileLineage) -> Path:
    """
    Write lineage metadata to sidecar file.

    Args:
        data_path: Path to the training data file
        lineage: FileLineage metadata

    Returns:
        Path to the written .meta.json file
    """
    meta_path = get_meta_path(data_path)

    try:
        with open(meta_path, 'w') as f:
            json.dump(lineage.to_dict(), f, indent=2)
        logger.debug(f"Wrote lineage metadata: {meta_path}")
        return meta_path
    except Exception as e:
        logger.warning(f"Failed to write lineage metadata to {meta_path}: {e}")
        raise


def read_file_lineage(data_path: Path) -> Optional[FileLineage]:
    """
    Read lineage metadata from sidecar file.

    Args:
        data_path: Path to the training data file

    Returns:
        FileLineage if sidecar exists, None otherwise
    """
    meta_path = get_meta_path(data_path)

    if not meta_path.exists():
        logger.debug(f"No lineage metadata found: {meta_path}")
        return None

    try:
        with open(meta_path) as f:
            data = json.load(f)
        return FileLineage.from_dict(data)
    except Exception as e:
        logger.warning(f"Failed to read lineage metadata from {meta_path}: {e}")
        return None


def update_file_lineage(data_path: Path, **updates) -> Optional[FileLineage]:
    """
    Update existing lineage metadata.

    Args:
        data_path: Path to the training data file
        **updates: Fields to update

    Returns:
        Updated FileLineage, or None if no existing metadata
    """
    lineage = read_file_lineage(data_path)
    if lineage is None:
        return None

    for key, value in updates.items():
        if hasattr(lineage, key):
            setattr(lineage, key, value)

    write_file_lineage(data_path, lineage)
    return lineage


# =============================================================================
# INFERENCE UTILITIES
# =============================================================================

def infer_generator_from_filename(filename: str) -> tuple:
    """
    Attempt to infer generator_id from filename patterns.

    Returns:
        (generator_id, generator_version) tuple, or ("unknown", "?")
    """
    filename_lower = filename.lower()

    # Check known patterns
    if "discrimination" in filename_lower:
        return ("discrimination", GENERATOR_REGISTRY["discrimination"]["version"])

    if "syllo" in filename_lower or "syllogism" in filename_lower:
        # Could be local or API - default to API since that's more common
        return ("syllo_api", GENERATOR_REGISTRY["syllo_api"]["version"])

    if "train_syllo" in filename_lower:
        return ("curriculum", GENERATOR_REGISTRY["curriculum"]["version"])

    if "auto_gen" in filename_lower:
        return ("curriculum", GENERATOR_REGISTRY["curriculum"]["version"])

    if "binary" in filename_lower or "train_binary" in filename_lower:
        return ("bin_api", GENERATOR_REGISTRY["bin_api"]["version"])

    return ("unknown", "?")


def get_or_infer_lineage(data_path: Path) -> FileLineage:
    """
    Get lineage from sidecar, or infer from filename if not available.

    Always returns a FileLineage (never None), inferring from filename
    if no sidecar exists.
    """
    lineage = read_file_lineage(data_path)
    if lineage:
        return lineage

    # Infer from filename
    gen_id, gen_ver = infer_generator_from_filename(data_path.name)

    return FileLineage(
        generator_id=gen_id,
        generator_version=gen_ver,
        source="inferred_from_filename",
        extra={"inferred": True}
    )


# =============================================================================
# REGISTRY UTILITIES
# =============================================================================

def get_generator_info(generator_id: str) -> Optional[Dict[str, Any]]:
    """Get info about a registered generator."""
    return GENERATOR_REGISTRY.get(generator_id)


def is_known_generator(generator_id: str) -> bool:
    """Check if generator_id is in the registry."""
    return generator_id in GENERATOR_REGISTRY


def list_generators() -> list:
    """List all registered generator IDs."""
    return list(GENERATOR_REGISTRY.keys())


# =============================================================================
# CLI / TESTING
# =============================================================================

if __name__ == "__main__":
    import sys

    print("Data Lineage Module")
    print("=" * 50)

    print("\nRegistered Generators:")
    for gen_id, info in GENERATOR_REGISTRY.items():
        print(f"  {gen_id}@{info['version']}")
        print(f"    Source: {info['source']}")
        print(f"    Desc: {info['description']}")

    # Test with a file if provided
    if len(sys.argv) > 1:
        test_path = Path(sys.argv[1])
        print(f"\nTesting with: {test_path}")

        lineage = get_or_infer_lineage(test_path)
        print(f"  Generator: {lineage.generator_id}@{lineage.generator_version}")
        print(f"  Generated: {lineage.generated_at}")
        print(f"  Source: {lineage.source}")
        if lineage.extra.get("inferred"):
            print("  (inferred from filename)")
