<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Layer Adaptation Monitor</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            font-family: "JetBrains Mono", "SF Mono", Consolas, monospace;
            background: #040614;
            color: #e5f1ff;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            margin: 0 0 10px 0;
            font-weight: 600;
        }
        .card {
            background: #0e1428;
            border: 1px solid #1f2a4a;
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 18px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
        }
        #topLayers div {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(0, 255, 136, 0.06);
            border: 1px solid rgba(0, 255, 136, 0.15);
        }
        #historyList {
            max-height: 260px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.5;
        }
        #historyList div {
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding: 6px 0;
        }
        .muted {
            color: #8aa0c6;
        }
        .badge {
            display: inline-block;
            padding: 3px 7px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }
        .badge-ok {
            background: rgba(0, 255, 136, 0.15);
            color: #19ff9b;
        }
        .badge-warn {
            background: rgba(255, 190, 64, 0.15);
            color: #ffbe40;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 16px;
        }
        .layer-row {
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s, border 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .layer-row:hover { border-color: rgba(0,255,136,0.4); }
        .layer-row.active { border-color: rgba(0,255,136,0.7); background: rgba(0,255,136,0.08); }
        .stage-tag {
            display:inline-block;
            padding:2px 6px;
            border-radius:4px;
            font-size:0.75em;
            margin-top:4px;
        }
        .stage-embedding { background: rgba(0,255,171,0.2); color:#00ffab; border:1px solid rgba(0,255,171,0.4); }
        .stage-early { background: rgba(0,128,255,0.2); color:#5bb1ff; border:1px solid rgba(0,128,255,0.4); }
        .stage-mid { background: rgba(255,153,0,0.2); color:#ffb347; border:1px solid rgba(255,153,0,0.4); }
        .stage-late { background: rgba(154,85,255,0.2); color:#d5a5ff; border:1px solid rgba(154,85,255,0.4); }
        .stage-output { background: rgba(255,76,76,0.2); color:#ff8a8a; border:1px solid rgba(255,76,76,0.4); }
        .small-text { font-size: 0.85em; }
        #statusLine { margin-bottom: 10px; }
        .scale-toggle {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0 4px 0;
        }
        .scale-toggle span {
            color: #8aa0c6;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .scale-toggle button {
            background: #0c1b3c;
            border: 1px solid #1f2a4a;
            color: #cde3ff;
            padding: 4px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .scale-toggle button.active {
            background: #1f4da8;
            border-color: #5ab0ff;
            color: #fff;
            box-shadow: 0 0 10px rgba(90, 176, 255, 0.45);
        }
    </style>
</head>
<body>
    <h1>Layer Adaptation Monitor</h1>
    <div id="statusLine" class="muted small-text">Waiting for trainer...</div>

    <div class="grid">
        <div class="card">
            <h2>Top Changing Layers</h2>
            <div id="summaryLine" class="muted small-text">Awaiting snapshot...</div>
            <div id="topLayers" style="margin-top: 12px;"></div>
        </div>
        <div class="card">
            <h2>Recent Snapshots</h2>
            <div id="historyList" class="muted small-text">No snapshots yet.</div>
        </div>
    </div>

    <div class="card">
        <h2>All Layers (click to inspect)</h2>
        <div class="muted small-text" style="margin-bottom:8px;">Stage info helps interpret behavior: Early = token/embedding, Mid = abstraction, Late = output head.</div>
        <div id="allLayersList" style="max-height:320px; overflow-y:auto;"></div>
    </div>

    <div class="card">
        <h2>Layer History Graph</h2>
        <div class="scale-toggle" id="scaleToggle">
            <span>Scale</span>
            <button type="button" data-scale-mode="linear" class="active">Linear</button>
            <button type="button" data-scale-mode="log">Log (10× bands)</button>
        </div>
        <div id="selectedLayerTitle" class="muted small-text">Select a layer to view its Δ history.</div>
        <canvas id="layerChart" width="800" height="250" style="margin-top:10px; background:#080b19; border-radius:8px; border:1px solid #1f2a4a;"></canvas>
    </div>

    <div class="card">
        <h2>Stage Overview (All Layers)</h2>
        <div class="muted small-text">Each line shows a layer's Δ history, color-coded by stage (embedding, early, mid, late, output). Opacity keeps overlapping lines readable.</div>
        <canvas id="allLayersChart" width="800" height="260" style="margin-top:10px; background:#080b19; border-radius:8px; border:1px solid #1f2a4a;"></canvas>
    </div>

    <div class="card">
        <h2>Snapshot Detail</h2>
        <pre id="rawJson" style="white-space: pre-wrap; font-size: 0.8em; background: #080b19; padding: 12px; border-radius: 8px; max-height: 260px; overflow-y: auto;">Waiting for data...</pre>
    </div>

    <script>
        const STATUS_FILE = '/status/training_status.json';
        const REFRESH_MS = 2000;
        const MAX_HISTORY = 30;

        const statusLine = document.getElementById('statusLine');
        const summaryLine = document.getElementById('summaryLine');
        const topLayersEl = document.getElementById('topLayers');
        const historyList = document.getElementById('historyList');
        const rawJson = document.getElementById('rawJson');

        const history = [];
        const layerHistories = new Map();
        const layerData = new Map();
        const layerOrder = [];
        const stageColors = {
            'stage-embedding': '#00ffab',
            'stage-early': '#5bb1ff',
            'stage-mid': '#ffb347',
            'stage-late': '#d5a5ff',
            'stage-output': '#ff8a8a'
        };
        let selectedLayer = null;
        const allLayersList = document.getElementById('allLayersList');
        const selectedLayerTitle = document.getElementById('selectedLayerTitle');
        const scaleButtons = document.querySelectorAll('[data-scale-mode]');
        let scaleMode = 'linear';

        async function poll() {
            try {
                const resp = await fetch(`${STATUS_FILE}?t=${Date.now()}`);
                if (!resp.ok) throw new Error(resp.statusText);
                const data = await resp.json();

                const step = data.current_step ?? 0;
                const file = data.current_file ?? 'unknown';
                statusLine.textContent = `Status: ${data.status?.toUpperCase()} · Step ${step.toLocaleString()} · File: ${file}`;

                const summary = data.layer_activity_summary;
                if (!summary || !summary.top_changes) {
                    summaryLine.innerHTML = 'Waiting for first snapshot...';
                    topLayersEl.innerHTML = '';
                    rawJson.textContent = 'No layer data yet.';
                    return;
                }

                rawJson.textContent = JSON.stringify(summary, null, 2);

                const overall = summary.overall || {};
                summaryLine.innerHTML = `
                    Layers tracked: <strong>${overall.total_layers ?? summary.top_changes.length}</strong>
                    · Avg Δ <strong>${formatNumber(overall.avg_delta)}</strong>
                    · Max Δ <strong>${formatNumber(overall.max_delta)}</strong>
                `;

                topLayersEl.innerHTML = summary.top_changes.map((entry, idx) => {
                    const rel = entry.relative_delta ? (entry.relative_delta * 100) : 0;
                    return `
                        <div>
                            <div style="display:flex;justify-content:space-between;">
                                <span style="color:#19ff9b;font-weight:bold;">${idx + 1}. ${entry.name}</span>
                                <span class="badge ${rel > 5 ? 'badge-warn' : 'badge-ok'}">Δ ${formatNumber(entry.delta)}</span>
                            </div>
                            <div class="muted small-text">
                                rel ${rel.toFixed(3)}% · avg ${formatNumber(entry.avg_delta)} · norm ${formatNumber(entry.norm)}
                            </div>
                        </div>
                    `;
                }).join('');

                history.unshift({
                    ts: summary.generated_at || new Date().toISOString(),
                    top: summary.top_changes[0]
                });
                if (history.length > MAX_HISTORY) history.pop();

                historyList.innerHTML = history.map(item => {
                    const change = item.top;
                    const rel = change.relative_delta ? (change.relative_delta * 100) : 0;
                    return `
                        <div>
                            <div style="display:flex;justify-content:space-between;">
                                <span>${new Date(item.ts).toLocaleTimeString()}</span>
                                <span class="badge ${rel > 5 ? 'badge-warn' : 'badge-ok'}">${formatNumber(change.delta)}</span>
                            </div>
                            <div class="muted">${change.name} · rel ${rel.toFixed(3)}%</div>
                        </div>
                    `;
                }).join('');

                const snapshotLayers = summary.all_layers || summary.top_changes;
                if (snapshotLayers && snapshotLayers.length) {
                    const timestamp = summary.generated_at || new Date().toISOString();
                    snapshotLayers.forEach(entry => {
                        layerData.set(entry.name, entry);
                        if (!layerOrder.includes(entry.name)) {
                            layerOrder.push(entry.name);
                            layerOrder.sort((a, b) => layerSortKey(a).localeCompare(layerSortKey(b)));
                        }
                        const arr = layerHistories.get(entry.name) || [];
                        arr.unshift({ ts: timestamp, delta: entry.delta });
                        if (arr.length > MAX_HISTORY) arr.pop();
                        layerHistories.set(entry.name, arr);
                    });
                    renderAllLayers();
                    if (!selectedLayer) {
                        selectLayer(layerOrder[0]);
                    } else {
                        renderAllLayers();
                    }
                    drawAllLayersChart();
                }

            } catch (err) {
                statusLine.textContent = `Error fetching status: ${err.message}`;
            } finally {
                setTimeout(poll, REFRESH_MS);
            }
        }

        function formatNumber(val) {
            if (!val && val !== 0) return '-';
            if (Math.abs(val) >= 1) return val.toFixed(3);
            return val.toExponential(3);
        }

        function getChartDims(canvas) {
            const padding = 28;
            return {
                left: padding,
                right: canvas.width - padding,
                top: padding,
                bottom: canvas.height - padding,
                width: canvas.width - padding * 2,
                height: canvas.height - padding * 2
            };
        }

        function computeScaleStats(values, mode) {
            if (!values || values.length === 0) return null;
            const maxVal = Math.max(...values);
            const minVal = Math.min(...values);
            if (mode === 'log') {
                const positives = values.filter(v => v > 0);
                if (!positives.length || maxVal <= 0) {
                    return computeScaleStats(values, 'linear');
                }
                const minPos = Math.min(...positives);
                const minOrder = Math.floor(Math.log10(minPos)) - 1;
                const maxOrder = Math.ceil(Math.log10(maxVal)) + 1;
                const axisMin = Math.pow(10, minOrder);
                const axisMax = Math.pow(10, maxOrder);
                const logMin = Math.log10(axisMin);
                const logMax = Math.log10(axisMax);
                return {
                    mode: 'log',
                    min: axisMin,
                    max: axisMax,
                    logMin,
                    logMax,
                    logRange: (logMax - logMin) || 1,
                    minOrder,
                    maxOrder
                };
            }

            const range = (maxVal - minVal) || Math.max(Math.abs(maxVal), 1) || 1;
            return {
                mode: 'linear',
                min: minVal,
                max: maxVal,
                range,
                minOrder: null,
                maxOrder: null
            };
        }

        function valueToY(value, stats, dims) {
            if (!stats) return dims.bottom;
            if (stats.mode === 'log') {
                const safeValue = Math.max(value, stats.min);
                const logVal = Math.log10(safeValue);
                const norm = (logVal - stats.logMin) / (stats.logRange || 1);
                const y = dims.bottom - norm * dims.height;
                return Math.min(Math.max(y, dims.top), dims.bottom);
            }
            const norm = (value - stats.min) / (stats.range || 1);
            const y = dims.bottom - norm * dims.height;
            return Math.min(Math.max(y, dims.top), dims.bottom);
        }

        function drawAxisLabels(ctx, dims, stats) {
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            if (stats.mode === 'log') {
                ctx.fillText(`1e${stats.maxOrder}`, dims.left + 4, dims.top + 10);
                ctx.fillText(`1e${stats.minOrder}`, dims.left + 4, dims.bottom - 4);
            } else {
                ctx.fillText(formatNumber(stats.max), dims.left + 4, dims.top + 10);
                ctx.fillText(formatNumber(stats.min), dims.left + 4, dims.bottom - 4);
            }
        }

        function drawLogBands(ctx, dims, stats) {
            if (!stats || stats.mode !== 'log') return;
            const colors = ['rgba(0, 173, 255, 0.08)', 'rgba(255,255,255,0.03)'];
            for (let order = stats.minOrder; order < stats.maxOrder; order++) {
                const lower = Math.pow(10, order);
                const upper = Math.pow(10, order + 1);
                const yLower = valueToY(lower, stats, dims);
                const yUpper = valueToY(upper, stats, dims);
                const top = Math.min(yLower, yUpper);
                const height = Math.abs(yLower - yUpper);
                ctx.fillStyle = colors[(order - stats.minOrder) % colors.length];
                ctx.fillRect(dims.left, top, dims.width, height);
                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath();
                ctx.moveTo(dims.left, top);
                ctx.lineTo(dims.right, top);
                ctx.stroke();
                ctx.fillStyle = '#4da3ff';
                ctx.font = '11px monospace';
                ctx.fillText(`1e${order}`, dims.right - 60, top - 4);
            }
        }

        function layerSortKey(name) {
            const lower = name.toLowerCase();
            if (lower.includes('embedding')) return '000_' + name;
            if (lower.includes('lm_head') || lower.includes('output')) return '999_' + name;
            const match = name.match(/layers\.(\d+)/);
            if (match) {
                return match[1].padStart(3, '0') + '_' + name;
            }
            return '500_' + name;
        }

        function describeLayer(name) {
            const lowered = name.toLowerCase();
            if (lowered.includes('embedding')) return { text: 'Embedding / token projection', tag: 'stage-embedding' };
            if (lowered.includes('lm_head') || lowered.includes('output')) return { text: 'Output head', tag: 'stage-output' };

            const match = name.match(/layers\.(\d+)/);
            if (match) {
                const idx = parseInt(match[1], 10);
                if (idx <= 7) return { text: `Early block ${idx} (input/features)`, tag: 'stage-early' };
                if (idx <= 17) return { text: `Mid block ${idx} (reasoning)`, tag: 'stage-mid' };
                return { text: `Late block ${idx} (output/refinement)`, tag: 'stage-late' };
            }
            return { text: 'Transformer block', tag: 'stage-mid' };
        }

        function renderAllLayers() {
            if (!layerOrder.length) {
                allLayersList.innerHTML = '<p class="muted">Waiting for data...</p>';
                return;
            }
            const html = layerOrder.map(name => {
                const entry = layerData.get(name);
                if (!entry) return '';
                const relPct = entry.relative_delta ? (entry.relative_delta * 100).toFixed(2) : '0.00';
                const stage = describeLayer(entry.name);
                const classes = ['layer-row'];
                if (entry.name === selectedLayer) classes.push('active');
                return `
                    <div class="${classes.join(' ')}" data-layer="${entry.name}">
                        <div>
                            <div style="font-weight:bold;color:#19ff9b;">${entry.name}</div>
                            <div class="stage-tag ${stage.tag}">${stage.text}</div>
                        </div>
                        <div style="text-align:right;">
                            <div>Δ ${formatNumber(entry.delta)}</div>
                            <div class="muted small-text">rel ${relPct}%</div>
                        </div>
                    </div>
                `;
            }).join('');
            allLayersList.innerHTML = html;
        }

        allLayersList.addEventListener('click', (event) => {
            const target = event.target.closest('.layer-row');
            if (!target) return;
            const layer = target.dataset.layer;
            selectLayer(layer);
        });

        function selectLayer(layerName) {
            if (!layerName) return;
            selectedLayer = layerName;
            const points = layerHistories.get(layerName) || [];
            selectedLayerTitle.textContent = `Layer: ${layerName}`;
            drawChart(points);
            renderAllLayers();
            drawAllLayersChart();
        }

        function drawChart(points) {
            const canvas = document.getElementById('layerChart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!points || points.length === 0) {
                ctx.fillStyle = '#555';
                ctx.fillText('No history yet for this layer.', 10, 30);
                return;
            }

            const reversed = [...points].reverse();
            const deltas = reversed.map(p => p.delta);
            const stats = computeScaleStats(deltas, scaleMode);
            if (!stats) return;
            const dims = getChartDims(canvas);
            if (stats.mode === 'log') {
                drawLogBands(ctx, dims, stats);
            }
            const denominator = reversed.length > 1 ? (reversed.length - 1) : 1;

            ctx.strokeStyle = '#1effa0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            reversed.forEach((point, idx) => {
                const x = dims.left + (idx / denominator) * dims.width;
                const y = valueToY(point.delta, stats, dims);
                if (idx === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            drawAxisLabels(ctx, dims, stats);
        }

        function drawAllLayersChart() {
            const canvas = document.getElementById('allLayersChart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!layerOrder.length) {
                ctx.fillStyle = '#555';
                ctx.fillText('Waiting for data...', 10, 30);
                return;
            }

            const series = layerOrder.map(name => ({
                name,
                history: layerHistories.get(name) || [],
                stage: describeLayer(name).tag
            })).filter(s => s.history.length >= 2);

            if (!series.length) {
                ctx.fillStyle = '#555';
                ctx.fillText('Not enough history yet.', 10, 30);
                return;
            }

            const allValues = [];
            let maxPoints = 0;
            series.forEach(s => {
                maxPoints = Math.max(maxPoints, s.history.length);
                s.history.forEach(p => allValues.push(p.delta));
            });
            const stats = computeScaleStats(allValues, scaleMode);
            if (!stats) {
                ctx.fillStyle = '#555';
                ctx.fillText('Not enough data for scaling.', 10, 30);
                return;
            }
            const dims = getChartDims(canvas);
            if (stats.mode === 'log') {
                drawLogBands(ctx, dims, stats);
            }
            const denom = maxPoints > 1 ? (maxPoints - 1) : 1;

            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.55;
            series.forEach(s => {
                const reversed = [...s.history].reverse();
                const color = stageColors[s.stage] || '#888';
                ctx.strokeStyle = color;
                ctx.beginPath();
                reversed.forEach((point, idx) => {
                    const x = dims.left + (idx / denom) * dims.width;
                    const y = valueToY(point.delta, stats, dims);
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            drawAxisLabels(ctx, dims, stats);

            let legendX = canvas.width - 150;
            let legendY = 20;
            Object.entries(stageColors).forEach(([stage, color]) => {
                ctx.fillStyle = color;
                ctx.fillRect(legendX, legendY, 14, 8);
                ctx.fillStyle = '#bbb';
                ctx.fillText(stage.replace('stage-', ''), legendX + 20, legendY + 8);
                legendY += 16;
            });
        }

        function setScaleMode(mode) {
            if (!mode || mode === scaleMode) return;
            scaleMode = mode;
            scaleButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.scaleMode === mode);
            });
            if (selectedLayer) {
                drawChart(layerHistories.get(selectedLayer) || []);
            }
            drawAllLayersChart();
        }

        scaleButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.scaleMode;
                setScaleMode(mode);
            });
        });

        poll();
    </script>
</body>
</html>
