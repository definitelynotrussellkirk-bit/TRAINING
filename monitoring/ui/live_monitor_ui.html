<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Training Live Monitor - Ultra Enhanced</title>
    <!-- Favicon for professional tab appearance -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>‚ö°</text></svg>">
    <!-- External CSS for easier maintenance -->
    <link rel="stylesheet" href="/monitoring/css/monitor_styles.css">
</head>
<body class="theme-dark">
    <!-- Keyboard Shortcuts Modal -->
    <div id="shortcutsModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeShortcutsModal()">&times;</span>
            <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
            <table>
                <tr><td><kbd>R</kbd></td><td>Force refresh (reload all data)</td></tr>
                <tr><td><kbd>F</kbd></td><td>Toggle fullscreen mode</td></tr>
                <tr><td><kbd>C</kbd></td><td>Toggle compact mode (hide sections)</td></tr>
                <tr><td><kbd>T</kbd></td><td>Toggle dark/light theme</td></tr>
                <tr><td><kbd>E</kbd></td><td>Export training data to JSON</td></tr>
                <tr><td><kbd>P</kbd></td><td>Pause/resume auto-refresh</td></tr>
                <tr><td><kbd>?</kbd> or <kbd>/</kbd></td><td>Show this help (shortcuts modal)</td></tr>
                <tr><td><kbd>Esc</kbd></td><td>Close modals and dialogs</td></tr>
            </table>
            <p style="text-align: center; margin-top: 20px; color: #888;">
                üí° Tip: Click on panel headers to collapse/expand sections!
            </p>
        </div>
    </div>

    <!-- NEW: Flagged Examples Floating Panel -->
    <div id="flaggedPanel" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;">üö© Flagged Training Examples</h2>
                <button id="closeFlaggedPanel" style="padding: 5px 15px; background: rgba(255, 68, 68, 0.2); border: 1px solid #ff4444; color: #ff4444; border-radius: 5px; cursor: pointer; font-size: 1em;">‚úï Close</button>
            </div>

            <!-- Statistics Summary -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
                <div style="background: rgba(42, 63, 95, 0.3); padding: 10px; border-radius: 5px; text-align: center;">
                    <div style="color: #888; font-size: 0.9em;">Total Flagged</div>
                    <div id="flaggedTotal" style="color: #00d9ff; font-size: 1.5em; font-weight: bold;">0</div>
                </div>
                <div style="background: rgba(42, 63, 95, 0.3); padding: 10px; border-radius: 5px; text-align: center;">
                    <div style="color: #888; font-size: 0.9em;">Mismatches</div>
                    <div id="flaggedMismatches" style="color: #ff4444; font-size: 1.5em; font-weight: bold;">0</div>
                </div>
                <div style="background: rgba(42, 63, 95, 0.3); padding: 10px; border-radius: 5px; text-align: center;">
                    <div style="color: #888; font-size: 0.9em;">High Loss</div>
                    <div id="flaggedHighLoss" style="color: #ffaa00; font-size: 1.5em; font-weight: bold;">0</div>
                </div>
                <div style="background: rgba(42, 63, 95, 0.3); padding: 10px; border-radius: 5px; text-align: center;">
                    <div style="color: #888; font-size: 0.9em;">Avg Loss</div>
                    <div id="flaggedAvgLoss" style="color: #00ff88; font-size: 1.5em; font-weight: bold;">0.00</div>
                </div>
            </div>

            <!-- Filter Controls -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                <select id="flaggedFilter" style="padding: 8px 12px; background: rgba(42, 63, 95, 0.5); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 5px; cursor: pointer; font-size: 0.95em;">
                    <option value="all">All Flagged</option>
                    <option value="mismatch">Mismatches Only</option>
                    <option value="high_loss">High Loss Only</option>
                    <option value="error">Errors Only</option>
                </select>
                <select id="flaggedSort" style="padding: 8px 12px; background: rgba(42, 63, 95, 0.5); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 5px; cursor: pointer; font-size: 0.95em;">
                    <option value="recent">Most Recent First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="highest_loss">Highest Loss First</option>
                    <option value="lowest_loss">Lowest Loss First</option>
                </select>
                <button id="refreshFlagged" style="padding: 8px 15px; background: rgba(0, 217, 255, 0.2); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 5px; cursor: pointer; font-size: 0.95em;">üîÑ Refresh</button>
            </div>

            <!-- Examples List (scrollable) -->
            <div id="flaggedExamplesList" style="flex: 1; overflow-y: auto; padding-right: 10px;">
                <div style="text-align: center; padding: 40px; color: #888;">
                    Loading flagged examples...
                </div>
            </div>
        </div>
    </div>

    <!-- ALWAYS-VISIBLE STATUS BAR (Persistent Summary) -->
    <div id="statusBar" class="status-bar-persistent">
        <!-- Binary Health Indicator -->
        <div class="health-indicator">
            <div class="health-dot" id="healthDot" title="System Health"></div>
            <span class="health-label" id="healthLabel">INITIALIZING</span>
        </div>

        <!-- Large Primary Metrics -->
        <div class="summary-metric">
            <span class="summary-label">STATUS</span>
            <span class="summary-value huge" id="summaryStatus">LOADING</span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">LOSS</span>
            <span class="summary-value big" id="summaryLoss">
                <span id="lossValue">-</span>
                <span class="delta-indicator" id="lossDelta"></span>
            </span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">PROGRESS</span>
            <span class="summary-value big" id="summaryProgress">
                <span id="progressValue">0%</span>
            </span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">GPU TEMP</span>
            <span class="summary-value medium" id="summaryGPU">
                <span id="gpuValue">-¬∞C</span>
                <span class="delta-indicator" id="gpuDelta"></span>
            </span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">THROUGHPUT</span>
            <span class="summary-value medium" id="summaryThroughput">
                <span id="throughputValue">-- MB/hr</span>
                <span class="delta-indicator" id="throughputDelta"></span>
            </span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">RAM</span>
            <span class="summary-value medium" id="summaryRAM">
                <span id="ramValue">- GB</span>
                <span class="delta-indicator" id="ramDelta"></span>
            </span>
        </div>

        <div class="summary-metric">
            <span class="summary-label">QUEUE</span>
            <span class="summary-value medium" id="summaryQueue">
                <span id="queueValue">-</span>
            </span>
        </div>
    </div>

    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h1 style="margin: 0;">‚ö° TRAINING LIVE MONITOR ‚ö°</h1>
            <div style="display: flex; gap: 10px;">
                <button id="themeToggle" class="control-button" aria-pressed="true">üåô Dark</button>
                <button id="compactToggle" class="control-button" aria-pressed="false">üì¶ Compact</button>
                <button id="pauseToggle" class="control-button" aria-pressed="false">‚è∏Ô∏è Pause</button>
                <button id="exportButton" class="control-button">üíæ Export</button>
                <button id="viewFlaggedButton" class="control-button">üö© Flagged (<span id="flaggedCount">0</span>)</button>
                <button id="soundToggle" class="control-button" aria-pressed="false">üîî Sound ON</button>
            </div>
        </div>

        <!-- Training Timer & ETA Countdown -->
        <div class="grid" style="margin-bottom: 15px;">
            <div class="timer-panel">
                <h3>‚è±Ô∏è Training Duration</h3>
                <div class="timer-display" id="trainingTimer">00:00:00</div>
            </div>
            <div class="timer-panel">
                <h3>‚è∞ ETA Current File</h3>
                <div class="timer-display" id="etaCountdown">00:00:00</div>
            </div>
            <div class="timer-panel throughput-panel">
                <h3>üìä Throughput
                    <div class="tooltip-icon inline" style="margin-left: 5px;">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Data Throughput</div>
                            Measures how fast training data is being processed.
                            <br><br>
                            <strong>Calculated from:</strong><br>
                            ‚Ä¢ File size (MB) of completed batches<br>
                            ‚Ä¢ Time taken to train on each batch<br>
                            ‚Ä¢ Rolling average over recent batches
                            <br><br>
                            <strong>Typical values:</strong><br>
                            ‚Ä¢ 10-20 MB/hour: Normal for 7B model<br>
                            ‚Ä¢ 20-40 MB/hour: Fast GPU/settings<br>
                            ‚Ä¢ < 10 MB/hour: Check GPU utilization
                            <br><br>
                            <strong>Used to estimate:</strong><br>
                            Queue completion time = (Total queued MB) √∑ (MB/hour)
                        </span>
                    </div>
                </h3>
                <div class="timer-display" id="throughput" style="font-size: 2em;">-- MB/hr</div>
                <div id="throughputDetails" style="font-size: 0.7em; color: #888; margin-top: 5px;">No data yet</div>
            </div>
        </div>

        <!-- Queue Time Estimator -->
        <div id="queueEstimator" class="panel queue-estimator" style="display: none; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 style="margin: 0;">üìÅ Queue Time Estimator
                    <div class="tooltip-icon" style="margin-left: 5px;">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Queue Completion Estimate</div>
                            Predicts when ALL queued files in inbox/ will finish training.
                            <br><br>
                            <strong>Calculation:</strong><br>
                            1. Sum all queued file sizes (MB)<br>
                            2. Divide by current throughput (MB/hour)<br>
                            3. Add to current time
                            <br><br>
                            <strong>Accuracy improves with:</strong><br>
                            ‚Ä¢ More completed batches (better average)<br>
                            ‚Ä¢ Stable training speed<br>
                            ‚Ä¢ Similar file sizes
                            <br><br>
                            <strong>Note:</strong> Estimate updates as throughput changes. First batch has no history, so initial estimate may be rough.
                        </span>
                    </div>
                </h2>
                <button id="toggleFileDetailsBtn" style="padding: 5px 12px; background: rgba(0, 217, 255, 0.2); border: 1px solid #00d9ff; color: #00d9ff; border-radius: 5px; cursor: pointer; font-size: 0.9em;">
                    üìã Show Details
                </button>
            </div>
            <div class="queue-stats">
                <div class="queue-stat">
                    <span class="queue-label">Files Queued:</span>
                    <span class="queue-value" id="queueCount">-</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-label">Total Size:</span>
                    <span class="queue-value" id="queueSize">- MB</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-label">Est. Time Remaining:</span>
                    <span class="queue-value highlight" id="queueETA">00:00:00</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-label">Est. Completion:</span>
                    <span class="queue-value highlight" id="queueCompleteTime">---</span>
                </div>
            </div>

            <!-- Detailed File List (expandable) -->
            <div id="queuedFilesList" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0, 217, 255, 0.2);">
                <h3 style="margin-bottom: 10px; color: #00d9ff; font-size: 0.95em;">üìã Queued Files Details</h3>
                <div id="filesListContainer" style="max-height: 300px; overflow-y: auto;">
                    <!-- Files will be inserted here -->
                </div>
            </div>
        </div>

        <div class="panel" id="advancedAnalyticsPanel" style="margin-bottom: 15px;">
            <h2>üß† Advanced Analytics</h2>
            <div class="analytics-grid">
                <div class="analytics-card">
                    <h3>Penalty Hits</h3>
                    <div id="penaltyStats" class="analytics-content">Collecting‚Ä¶</div>
                </div>
                <div class="analytics-card">
                    <h3>Queue Velocity</h3>
                    <div id="queueVelocityStats" class="analytics-content">--</div>
                </div>
                <div class="analytics-card">
                    <h3>Length Coverage</h3>
                    <div id="lengthCoverageList" class="analytics-content">--</div>
                </div>
                <div class="analytics-card">
                    <h3>Pattern Loss</h3>
                    <div id="patternLossList" class="analytics-content">--</div>
                </div>
                <div class="analytics-card">
                    <h3>Pattern ‚áÑ Layer</h3>
                    <div id="patternLayerList" class="analytics-content">--</div>
                </div>
                <div class="analytics-card">
                    <h3>Layer Stability</h3>
                    <div id="layerStabilityList" class="analytics-content">--</div>
                </div>
            </div>
            <div class="analytics-subpanel">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <h3 style="margin:0;">Throughput vs VRAM</h3>
                    <span id="vramScatterStatus" class="muted small-text">Waiting for samples‚Ä¶</span>
                </div>
                <canvas id="vramScatter" width="640" height="240" style="width: 100%; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; background: rgba(5,10,20,0.6);"></canvas>
            </div>
        </div>

        <!-- ========================================
             OVERALL PROGRESS BAR SECTION
             ======================================== -->
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span style="color: #00d9ff; font-weight: bold;">Overall Progress
                    <div class="tooltip-icon inline" style="margin-left: 5px;">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Overall Progress</div>
                            Shows current training step / total training steps for the current batch.
                            <br><br>
                            <strong>In your setup:</strong><br>
                            ‚Ä¢ Each .jsonl file in inbox/ becomes one "batch"<br>
                            ‚Ä¢ This shows progress through the CURRENT file<br>
                            ‚Ä¢ 100% = current file completed, moves to next file
                            <br><br>
                            <strong>Multiple files:</strong><br>
                            If you have 3 files queued, this will go 0‚Üí100% three times (once per file)
                            <br><br>
                            <strong>Continuous training:</strong><br>
                            Adapter preserves learning between batches via checkpoints
                        </span>
                    </div>
                </span>
                <span id="overallProgressText" style="color: #00ff88; font-weight: bold;">0%</span>
            </div>
            <div id="overallProgressContainer"
                 class="progress-container"
                 style="height: 30px;"
                 role="progressbar"
                 aria-label="Overall Progress"
                 aria-valuemin="0"
                 aria-valuemax="100"
                 aria-valuenow="0">
                <div id="overallProgressBar" class="progress-bar" style="width: 0%;">
                    <span id="overallProgressLabel">0%</span>
                </div>
            </div>
        </div>

        <!-- ========================================
             STATUS INDICATORS (Top Right)
             ======================================== -->
        <div class="refresh-indicator">
            <span id="refreshStatus">Initializing...</span>
        </div>

        <div class="files-indicator" id="filesIndicator" style="display: none; cursor: pointer;" title="Click to show/hide file details">
            üìÅ Queued Files: <span class="files-badge" id="filesCount">0</span>
            <span id="filesToggleIcon" style="margin-left: 5px; font-size: 0.8em;">‚ñº</span>
        </div>

        <!-- ========================================
             ERROR MESSAGES (if any)
             ======================================== -->
        <div id="errorContainer"></div>

        <!-- ========================================
             LORA CONFIGURATION SECTION
             ======================================== -->
        <div class="section-divider">‚öôÔ∏è MODEL CONFIGURATION</div>
        <div class="grid-4 compactable" style="margin-bottom: 15px;">
            <!-- Layer Monitor: total layers -->
            <div class="panel panel-lora">
                <h2>üî¢ Layers Tracked
                    <div class="tooltip-icon">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Layer Groups</div>
                            Shows how many transformer blocks the layer monitor is tracking in the current run. During full-model training every block is tracked; during adapter-only runs this matches the number of trainable layers.
                        </span>
                    </div>
                </h2>
                <div class="value-big" id="loraRank" style="font-size: 2em;">-</div>
            </div>

            <!-- Layer Monitor: avg delta -->
            <div class="panel panel-lora">
                <h2>‚öñÔ∏è Avg Œî (Weight Norm)
                    <div class="tooltip-icon">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Average Layer Delta</div>
                            Displays the mean change in weight norm between snapshots across all monitored layers. Larger values mean the model is adapting more aggressively.
                        </span>
                    </div>
                </h2>
                <div class="value-big" id="loraAlpha" style="font-size: 2em;">-</div>
            </div>

            <!-- Batch size / accumulation -->
            <div class="panel panel-config">
                <h2>üéØ Batch & Accumulation
                    <div class="tooltip-icon">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Effective Batch Size</div>
                            Shows the per-device batch size and gradient accumulation steps flowing through the trainer. Effective batch = batch √ó accumulation.
                        </span>
                    </div>
                </h2>
                <div style="display:flex; justify-content:space-around; font-size:1.2em; margin-top:10px;">
                    <div>
                        <div class="muted small-text">Batch</div>
                        <div id="batchSize">-</div>
                    </div>
                    <div>
                        <div class="muted small-text">Acc</div>
                        <div id="gradAccum">-</div>
                    </div>
                    <div>
                        <div class="muted small-text">Effective</div>
                        <div id="effectiveBatch">-</div>
                    </div>
                </div>
            </div>

            <!-- Model Name -->
            <div class="panel panel-config">
                <h2>ü§ñ Base Model</h2>
                <div style="margin-top: 15px; text-align: center; font-size: 1em; color: #00d9ff; font-weight: bold;" id="modelName">-</div>
            </div>
        </div>

        <!-- ========================================
             MAIN STATISTICS GRID
             ======================================== -->
        <div class="section-divider">üìä TRAINING METRICS</div>
        <div class="grid compactable">
            <!-- Training Status -->
            <div class="panel">
                <h2>üìä Training Status</h2>
                <div class="metric">
                    <span class="metric-label">Status
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Training Status</div>
                                <strong>idle:</strong> Waiting for data<br>
                                <strong>training:</strong> Actively training<br>
                                <strong>completed:</strong> Finished<br>
                                <strong>crashed:</strong> Error occurred
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="status">Loading...</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Current Step
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Current Step</div>
                                Training step number. Each step processes one batch of examples.
                                <br><br>
                                <strong>Batch size √ó accumulation steps = effective batch</strong><br>
                                Current: 1 √ó 8 = 8 examples per step
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="currentStep">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Steps
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Total Steps</div>
                                Total training steps for this run.
                                <br><br>
                                Calculated as: (Dataset size √∑ Effective batch size) √ó Epochs
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="totalSteps">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Epoch
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Epoch</div>
                                One complete pass through the entire training dataset.
                                <br><br>
                                <strong>Common practice:</strong><br>
                                1 epoch for large datasets<br>
                                3-10 epochs for smaller datasets
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="epoch">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Progress</span>
                    <span class="metric-value" id="progressPercent">0%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Max Output Tokens
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Max Output Tokens</div>
                                Maximum tokens the model can generate in responses.
                                <br><br>
                                <strong>Typical values:</strong><br>
                                ‚Ä¢ 256-512: Short answers<br>
                                ‚Ä¢ 1024-2048: Medium responses<br>
                                ‚Ä¢ 4096+: Long-form content
                                <br><br>
                                <strong>Effects:</strong><br>
                                Higher = More VRAM, longer generation time
                            </span>
                        </div>
                    </span>
                    <span class="metric-value success" id="maxOutputTokens">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Context Window
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Context Window</div>
                                Maximum total tokens (input + output) model can process at once.
                                <br><br>
                                <strong>Typical values:</strong><br>
                                ‚Ä¢ 2048: Older models<br>
                                ‚Ä¢ 4096-8192: Standard<br>
                                ‚Ä¢ 32768+: Extended context
                                <br><br>
                                <strong>Influences:</strong><br>
                                ‚Ä¢ How much conversation history fits<br>
                                ‚Ä¢ VRAM usage (grows quadratically!)<br>
                                ‚Ä¢ Training/inference speed
                                <br><br>
                                Larger context = exponentially more memory & compute
                            </span>
                        </div>
                    </span>
                    <span class="metric-value success" id="contextWindow">-</span>
                </div>
                <div class="progress-container" role="progressbar" aria-label="Training Progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" id="progressContainer">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>
            </div>

            <!-- Loss Metrics with Sparkline -->
            <div class="panel">
                <h2>üìâ Loss Metrics</h2>
                <div class="value-big" id="currentLoss" style="position: relative;">
                    -
                    <div class="tooltip-icon" style="font-size: 0.4em; position: absolute; top: 5px; right: 5px;">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Training Loss</div>
                            Measures how wrong the model's predictions are. Lower = better.
                            <br><br>
                            <strong>Typical progression:</strong><br>
                            ‚Ä¢ Start: 2.0-4.0 (random)<br>
                            ‚Ä¢ Early training: 1.0-2.0<br>
                            ‚Ä¢ Well-trained: 0.3-0.8<br>
                            ‚Ä¢ Overfitting: < 0.1
                            <br><br>
                            Color coding: Green=improving, Red=worsening, Orange=stable
                        </span>
                    </div>
                </div>
                <!-- Loss Sparkline Chart -->
                <canvas id="lossSparkline" width="250" height="60" style="width: 100%; height: 60px; margin: 10px 0;"></canvas>

                <!-- NEW: Streaming CE (EMA) -->
                <div class="metric">
                    <span class="metric-label">Streaming CE (EMA-300)
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Streaming Cross-Entropy (Smoothed)</div>
                                Exponential moving average of loss over ~300 steps.
                                <br><br>
                                <strong>Why this matters:</strong> Per-step loss is noisy. This smooths it out.
                                <br><br>
                                Use this instead of raw loss to see true trends.
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="streamingCE">-</span>
                </div>

                <!-- NEW: Token Entropy -->
                <div class="metric">
                    <span class="metric-label">Token Entropy (current)
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Token-Level Entropy</div>
                                Average uncertainty per token. Measures how "spread out" the probability distribution is.
                                <br><br>
                                <strong>High entropy:</strong> Model is unsure (multiple plausible tokens)<br>
                                <strong>Low entropy:</strong> Model is confident (one clear answer)
                                <br><br>
                                Typical range: 0.5-3.0
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="tokenEntropy">-</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Learning Rate
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Learning Rate</div>
                                Controls how much the model updates per step.
                                <br><br>
                                <strong>Typical values:</strong><br>
                                ‚Ä¢ 1e-5 to 5e-5: Conservative<br>
                                ‚Ä¢ 1e-4 to 5e-4: Standard<br>
                                ‚Ä¢ 1e-3+: Aggressive (risky)
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="learningRate">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Loss Trend
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Loss Trend</div>
                                Compares recent 10 steps vs previous 10 steps.
                                <br><br>
                                <strong>‚Üì Decreasing:</strong> Model learning (good!)<br>
                                <strong>‚Üë Increasing:</strong> Potential problem<br>
                                <strong>‚Üí Stable:</strong> Plateaued
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="lossTrend">-</span>
                </div>
            </div>

            <!-- Speed & ETA -->
            <div class="panel">
                <h2>‚è±Ô∏è Speed & ETA</h2>

                <!-- NEW: Tokens/sec -->
                <div class="metric">
                    <span class="metric-label">Tokens/Second
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Tokens Per Second</div>
                                Actual throughput in tokens (proper normalization).
                                <br><br>
                                <strong>Why this matters:</strong> MB/hr varies with file size. Tokens/sec is consistent.
                                <br><br>
                                <strong>Typical for sub-1B models:</strong><br>
                                ‚Ä¢ 4000-8000 tok/s: Good<br>
                                ‚Ä¢ 8000-15000 tok/s: Excellent<br>
                                ‚Ä¢ < 4000 tok/s: Check GPU utilization
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="tokensPerSec">-</span>
                </div>

                <!-- NEW: Effective tokens/step -->
                <div class="metric">
                    <span class="metric-label">Effective Tokens/Step
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Effective Tokens Per Step</div>
                                Total tokens processed per training step (batch √ó accumulation √ó avg length).
                                <br><br>
                                Higher = more compute per step, but slower steps.
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="tokensPerStep">-</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Steps/Second
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Steps Per Second</div>
                                Training throughput - how fast steps complete.
                                <br><br>
                                <strong>Typical ranges:</strong><br>
                                ‚Ä¢ 0.5-1.0: Normal for 7B model<br>
                                ‚Ä¢ 1.0-2.0: Fast (good GPU)<br>
                                ‚Ä¢ < 0.5: Slow (check GPU util)
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="stepsPerSec">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Examples/Second
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Examples Per Second</div>
                                Training examples processed per second.
                                <br><br>
                                Calculated: steps/sec √ó effective batch size (8)
                                <br><br>
                                Higher = faster training, but quality depends on other factors
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="examplesPerSec">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Time Elapsed</span>
                    <span class="metric-value" id="timeElapsed">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">ETA Remaining</span>
                    <span class="metric-value" id="etaRemaining">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Estimated Completion</span>
                    <span class="metric-value" id="etaTime">-</span>
                </div>
            </div>
        </div>

        <div class="section-divider">üéÆ HARDWARE STATUS</div>

        <!-- System RAM Stats -->
        <div class="panel compactable">
            <h2>üíæ System RAM - <span id="ramStatus">Loading...</span></h2>

            <div class="stat-grid" style="margin-bottom: 15px;">
                <div class="stat-card">
                    <div class="stat-card-label">Used RAM
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">System RAM Usage</div>
                                Total system memory in use.
                                <br><br>
                                <strong>Warning levels:</strong><br>
                                ‚Ä¢ < 70%: Safe (green)<br>
                                ‚Ä¢ 70-85%: Caution (yellow)<br>
                                ‚Ä¢ > 85%: High risk (red) - OOM killer may activate<br>
                                <br>
                                Monitor this during training to prevent crashes!
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="ramUsed">- GB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Training Process
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Training Process Memory</div>
                                RAM used by the Python training process.
                                <br><br>
                                <strong>Typical usage:</strong><br>
                                ‚Ä¢ 5-15 GB: Normal (tokenization phase)<br>
                                ‚Ä¢ 15-30 GB: Medium load<br>
                                ‚Ä¢ > 40 GB: Memory leak risk!<br>
                                <br>
                                If this grows continuously, may indicate memory leak.
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="trainingRAM">- GB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Available RAM
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Available RAM</div>
                                RAM available for new processes.
                                <br><br>
                                System keeps buffers/cache that can be freed if needed.<br>
                                This shows truly available memory.
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="ramAvailable">- GB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">OOM Risk
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Out of Memory Risk</div>
                                Risk level of OOM killer terminating processes.
                                <br><br>
                                <strong>LOW:</strong> Plenty of RAM (< 70%)<br>
                                <strong>MEDIUM:</strong> Getting full (70-85%)<br>
                                <strong>HIGH:</strong> Critical (> 85%) - crash imminent!<br>
                                <br>
                                If HIGH, consider restarting training or reducing dataset size.
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="oomRisk">LOW</div>
                </div>
            </div>

            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>System RAM</span>
                    <span id="ramLabel">- GB / - GB</span>
                </div>
                <div class="gpu-gauge" id="ramGaugeWrap" role="progressbar" aria-label="System RAM" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-mem" id="ramGauge" style="width: 0%"></div>
                </div>
            </div>

            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>Training Process</span>
                    <span id="trainingRAMLabel">- GB</span>
                </div>
                <div class="gpu-gauge" id="trainingRAMGaugeWrap" role="progressbar" aria-label="Training Process RAM" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-power" id="trainingRAMGauge" style="width: 0%"></div>
                </div>
            </div>

            <div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>Swap Usage</span>
                    <span id="swapLabel">- GB / - GB</span>
                </div>
                <div class="gpu-gauge" id="swapGaugeWrap" role="progressbar" aria-label="Swap Usage" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-util" id="swapGauge" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- GPU Stats -->
        <div class="panel compactable">
            <h2>üéÆ GPU Stats - <span id="gpuName">Loading...</span></h2>

            <div class="stat-grid" style="margin-bottom: 15px;">
                <div class="stat-card">
                    <div class="stat-card-label">Temperature
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">GPU Temperature</div>
                                <strong>Safe ranges:</strong><br>
                                ‚Ä¢ < 70¬∞C: Cool (ideal)<br>
                                ‚Ä¢ 70-80¬∞C: Warm (normal)<br>
                                ‚Ä¢ 80-85¬∞C: Hot (careful)<br>
                                ‚Ä¢ > 85¬∞C: Too hot! (reduce load)
                                <br><br>
                                <strong>Causes of high temp:</strong><br>
                                ‚Ä¢ High GPU utilization<br>
                                ‚Ä¢ Poor cooling/ventilation<br>
                                ‚Ä¢ Large batch sizes
                                <br><br>
                                Monitor turns red > 80¬∞C
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="gpuTemp">-¬∞C</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Power Draw
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Power Draw</div>
                                Current power consumption vs max rated power.
                                <br><br>
                                <strong>Typical for training:</strong><br>
                                ‚Ä¢ 50-80% of max: Normal<br>
                                ‚Ä¢ 80-100%: High utilization (good!)<br>
                                ‚Ä¢ < 50%: Underutilized GPU
                                <br><br>
                                Higher = more compute happening (usually good during training)
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="gpuPower">- W</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">GPU Utilization
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">GPU Utilization</div>
                                Percentage of GPU compute cores actively working.
                                <br><br>
                                <strong>Target for training:</strong><br>
                                ‚Ä¢ 80-100%: Excellent (GPU fully utilized)<br>
                                ‚Ä¢ 50-80%: Good<br>
                                ‚Ä¢ < 50%: CPU bottleneck or waiting for data
                                <br><br>
                                <strong>Low utilization causes:</strong><br>
                                ‚Ä¢ Data loading too slow<br>
                                ‚Ä¢ Batch size too small<br>
                                ‚Ä¢ CPU preprocessing bottleneck
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="gpuUtilPercent">-%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Memory Used
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">GPU Memory (VRAM)</div>
                                Video memory used for model weights, activations, and gradients.
                                <br><br>
                                <strong>What uses VRAM:</strong><br>
                                ‚Ä¢ Model base weights (largest)<br>
                                ‚Ä¢ LoRA adapter weights<br>
                                ‚Ä¢ Batch size √ó sequence length<br>
                                ‚Ä¢ Gradient accumulation buffers<br>
                                ‚Ä¢ Optimizer states (Adam = 2x params)
                                <br><br>
                                <strong>Running out of memory:</strong><br>
                                Reduce batch size, sequence length, or LoRA rank
                            </span>
                        </div>
                    </div>
                    <div class="stat-card-value" id="gpuMemUsed">- GB</div>
                </div>
            </div>

            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>Temperature</span>
                    <span id="tempLabel">-¬∞C / 85¬∞C</span>
                </div>
                <div class="gpu-gauge" id="tempGaugeWrap" role="progressbar" aria-label="GPU Temperature" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-temp" id="tempGauge" style="width: 0%"></div>
                </div>
            </div>

            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>GPU Utilization</span>
                    <span id="utilLabel">-%</span>
                </div>
                <div class="gpu-gauge" id="utilGaugeWrap" role="progressbar" aria-label="GPU Utilization" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-util" id="utilGauge" style="width: 0%"></div>
                </div>
            </div>

            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>Memory</span>
                    <span id="memLabel">- GB / - GB</span>
                </div>
                <div class="gpu-gauge" id="memGaugeWrap" role="progressbar" aria-label="GPU Memory" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-mem" id="memGauge" style="width: 0%"></div>
                </div>
            </div>

            <div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.85em;">
                    <span>Power Draw</span>
                    <span id="powerLabel">- W / - W</span>
                </div>
                <div class="gpu-gauge" id="powerGaugeWrap" role="progressbar" aria-label="Power Draw" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="gpu-gauge-fill gauge-power" id="powerGauge" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="section-divider">üéØ EVALUATION RESULTS</div>

        <!-- Smart Alerts (NEW) -->
        <div id="smartAlerts" style="margin-bottom: 15px;"></div>

        <!-- Fixed Eval Set (NEW) - GROUND TRUTH SIGNAL -->
        <div class="panel compactable">
            <h2>üéØ Fixed Eval Set (Ground Truth)
                <div class="tooltip-icon">‚ÑπÔ∏è
                    <span class="tooltiptext">
                        <div class="tooltip-header">Fixed Validation Set</div>
                        Held-out examples (never trained on) for true performance signal.
                        <br><br>
                        <strong>EM (Exact Match):</strong> % of perfect matches<br>
                        <strong>CE (Cross Entropy):</strong> Teacher-forced loss (no label smoothing)<br>
                        <strong>ECE (Calibration Error):</strong> How well confidence matches accuracy
                        <br><br>
                        This is your <strong>north star</strong> - streaming loss is noisy, this is truth.
                    </span>
                </div>
            </h2>
            <div class="metric">
                <span class="metric-label">Exact Match (EM)</span>
                <span class="metric-value" id="fixedEvalEM">-%</span>
            </div>
            <div class="metric">
                <span class="metric-label">Cross Entropy (CE)</span>
                <span class="metric-value" id="fixedEvalCE">-</span>
            </div>
            <div class="metric">
                <span class="metric-label">ECE (Calibration)</span>
                <span class="metric-value" id="fixedEvalECE">-</span>
            </div>
            <div class="metric">
                <span class="metric-label">Best Checkpoint</span>
                <span class="metric-value highlight" id="fixedEvalBest">‚Äî</span>
            </div>
            <div class="metric">
                <span class="metric-label">Trend</span>
                <span class="metric-value" id="fixedEvalTrend">-</span>
            </div>
        </div>

        <!-- Running Accuracy -->
        <div class="panel compactable">
            <h2>üéØ Running Accuracy
                <div class="tooltip-icon">‚ÑπÔ∏è
                    <span class="tooltiptext">
                        <div class="tooltip-header">Running Accuracy</div>
                        Percentage of evaluation examples where model output exactly matches expected answer.
                        <br><br>
                        <strong>Interpretation:</strong><br>
                        ‚Ä¢ > 90%: Excellent learning<br>
                        ‚Ä¢ 70-90%: Good progress<br>
                        ‚Ä¢ 50-70%: Early training<br>
                        ‚Ä¢ < 50%: Just starting
                        <br><br>
                        Note: Evaluations happen every 25 steps on training examples
                    </span>
                </div>
            </h2>
            <div class="value-big" id="accuracyPercent">-%</div>
            <div class="metric">
                <span class="metric-label">Correct / Total Evaluations</span>
                <span class="metric-value" id="accuracyFraction">- / -</span>
            </div>

            <!-- Accuracy Trends Section -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #2a3f5f;">
                <h3 style="font-size: 1em; margin-bottom: 10px; color: #00d9ff;">üìà Accuracy Trends
                    <div class="tooltip-icon inline" style="margin-left: 5px;">‚ÑπÔ∏è
                        <span class="tooltiptext">
                            <div class="tooltip-header">Accuracy Trends</div>
                            Compares accuracy over different time windows to show learning progress.
                            <br><br>
                            <strong>Last 20 evals:</strong> Most recent performance (short-term)<br>
                            <strong>Last 50 evals:</strong> Medium-term trend<br>
                            <strong>Overall:</strong> All-time average since training started
                            <br><br>
                            <strong>What to look for:</strong><br>
                            ‚Ä¢ Recent > Overall = Model improving! üéâ<br>
                            ‚Ä¢ Recent < Overall = Model regressing üòü<br>
                            ‚Ä¢ All similar = Model plateaued üìä<br>
                            <br>
                            Color coding: Green=improving, Yellow=stable, Red=regressing
                        </span>
                    </div>
                </h3>

                <div class="metric">
                    <span class="metric-label">Last 20 Evaluations
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Last 20 Evaluations</div>
                                Accuracy on the most recent 20 evaluation examples.
                                <br><br>
                                This shows <strong>short-term performance</strong> and reacts quickly to changes.
                                <br><br>
                                If significantly higher than overall: Model is improving!<br>
                                If significantly lower: May need to investigate
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="accuracy20">-% (-/-)</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Last 50 Evaluations
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Last 50 Evaluations</div>
                                Accuracy on the most recent 50 evaluation examples.
                                <br><br>
                                This shows <strong>medium-term trend</strong> and is more stable than Last 20.
                                <br><br>
                                Good for seeing sustained improvement or issues
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="accuracy50">-% (-/-)</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Trend Analysis
                        <div class="tooltip-icon inline">‚ÑπÔ∏è
                            <span class="tooltiptext">
                                <div class="tooltip-header">Trend Analysis</div>
                                Compares recent performance to overall average.
                                <br><br>
                                <strong>‚Üë Improving:</strong> Recent accuracy > overall (good!)<br>
                                <strong>‚Üí Stable:</strong> Recent ‚âà overall (plateaued)<br>
                                <strong>‚Üì Regressing:</strong> Recent < overall (investigate)
                            </span>
                        </div>
                    </span>
                    <span class="metric-value" id="accuracyTrend">-</span>
                </div>
            </div>
        </div>

        <!-- Current Example - All Four Components -->
        <div class="panel compactable">
            <h2>üîß System Prompt (Step <span id="currentExampleStep">-</span>)</h2>
            <div class="sample-box">
                <pre id="systemPrompt" style="color: #88ccff;">Waiting for validation step...</pre>
            </div>
        </div>

        <div class="panel compactable">
            <h2>üìù User Message</h2>
            <div class="sample-box">
                <pre id="prompt">Waiting for validation step...</pre>
            </div>
        </div>

        <div class="grid-2 compactable">
            <div class="panel">
                <h2>‚úÖ Expected (Golden Answer)</h2>
                <div class="sample-box">
                    <pre id="golden">Waiting for validation step...</pre>
                </div>
            </div>
            <div class="panel">
                <h2>ü§ñ Model Output<span id="matchBadge"></span></h2>
                <div class="sample-box">
                    <pre id="modelAnswer">Waiting for validation step...</pre>
                </div>
            </div>
        </div>

        <!-- Recent Examples History -->
        <div class="panel compactable">
            <h2>üìú Recent Evaluations (Model Outputs Only)</h2>
            <div id="recentExamples" style="font-size: 0.85em;">
                <p style="color: #888;">No model evaluations yet (waiting for next eval step)...</p>
            </div>
        </div>

        <div class="section-divider">üî¨ ANALYSIS & INSIGHTS</div>

        <div class="panel compactable">
            <h2>üß† Layer Adaptation Monitor
                <div class="tooltip-icon">‚ÑπÔ∏è
                    <span class="tooltiptext">
                        <div class="tooltip-header">Per-Layer Weight Changes</div>
                        Tracks how much each transformer block's weight norm changes between snapshots.
                        Useful for spotting dead layers or bursts of learning.
                    </span>
                </div>
            </h2>
            <div id="layerActivitySummary" style="color: #888; margin-bottom: 10px;">
                Waiting for first snapshot...
            </div>
            <div id="layerActivityTop" style="font-family: monospace; font-size: 0.85em; line-height: 1.6;"></div>
        </div>

    </div>

    <script>
        const STATUS_FILE = '/status/training_status.json';
        const GPU_STATS_API = '/api/gpu_stats';
        const MEMORY_STATS_API = 'http://localhost:8081/api/memory_stats';
        const INBOX_FILES_API = '/api/inbox_files';
        const CONFIG_API = '/api/config';
        const BASE_REFRESH_MS = 2000; // 2 seconds
        const EFFECTIVE_BATCH_SIZE = 8;
        const EMA_ALPHA = 0.25; // For steps/sec smoothing

        // Constants for thresholds
        const LIMITS = {
            GPU_TEMP_WARN: 70,
            GPU_TEMP_HOT: 80,
            GPU_TEMP_DANGER: 85,
            RAM_WARN: 70,
            RAM_DANGER: 85,
            TRAINING_MEM_WARN: 30,
            TRAINING_MEM_DANGER: 40,
            STALE_DATA_SEC: 10,
            MAX_ERROR_RETRIES: 5,
            MAX_BACKOFF_MS: 30000
        };

        let lastStep = 0;
        let lastTimestamp = null;
        let lastServerTimestamp = null;
        let startStep = null;
        let startTime = null;
        let lossHistory = [];
        let compactMode = localStorage.getItem('tlm:compactMode') === 'true';
        let darkTheme = localStorage.getItem('tlm:darkTheme') !== 'false'; // Default dark
        let soundEnabled = localStorage.getItem('tlm:soundEnabled') === 'true';
        let isPaused = false;
        let trainingStartTime = null;
        let hasCompletedBefore = false;
        let lastStatusForNotification = null;
        let stepsPerSecEMA = null;
        let errorCount = 0;
        let currentBackoff = 0;
        let inFlight = false;
        let pollTimer = null;
        let lastUpdateTime = Date.now();

        // Accuracy tracking for trend analysis
        let accuracyHistory = []; // Array of {step: number, correct: boolean}

        // Throughput tracking
        let throughputHistory = []; // Array of {mb: number, hours: number}
        let currentFileSizeMB = 0;
        let currentFileStartTime = null;

        // Delta tracking for change indicators
        let previousValues = {
            loss: null,
            gpuTemp: null,
            throughput: null,
            status: null,
            progress: null,
            ramUsed: null
        };

        // Apply saved preferences
        if (compactMode) document.body.classList.add('compact-mode');
        if (!darkTheme) document.body.classList.replace('theme-dark', 'theme-light');

        // --- Safer formatting helpers ---
        function formatTime(seconds) {
            if (!Number.isFinite(seconds) || seconds < 0) return '-';
            seconds = Math.floor(seconds);
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            if (h) return `${h}h ${m}m ${s}s`;
            if (m) return `${m}m ${s}s`;
            return `${s}s`;
        }

        function formatTimeHHMMSS(seconds) {
            if (!Number.isFinite(seconds) || seconds < 0) return '00:00:00';
            seconds = Math.floor(seconds);
            const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const s = String(seconds % 60).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // --- Sanitize untrusted text (XSS protection) ---
        function escapeHTML(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/`/g, '&#96;');
        }

        // --- Retina-friendly sparkline ---
        function drawLossSparkline(lossData) {
            const canvas = document.getElementById('lossSparkline');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            // Scale the backing store to device pixels
            if (canvas.width !== Math.round(rect.width * dpr) || canvas.height !== Math.round(rect.height * dpr)) {
                canvas.width = Math.round(rect.width * dpr);
                canvas.height = Math.round(rect.height * dpr);
            }
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels

            const width = rect.width;
            const height = rect.height;

            ctx.clearRect(0, 0, width, height);
            if (lossData.length < 2) return;

            const minLoss = Math.min(...lossData);
            const maxLoss = Math.max(...lossData);
            const range = (maxLoss - minLoss) || 1;

            // grid
            ctx.strokeStyle = '#2a3f5f';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // line
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const stepX = width / (lossData.length - 1);
            lossData.forEach((loss, i) => {
                const x = i * stepX;
                const y = height - ((loss - minLoss) / range) * (height - 10) - 5;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // labels
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.fillText(maxLoss.toFixed(3), 5, 10);
            ctx.fillText(minLoss.toFixed(3), 5, height - 2);
        }

        function playCompletionSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.value = 0.3;

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.error('Failed to play sound:', e);
            }
        }

        // --- Helper: Animate value change ---
        function animateValueChange(elementId) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.classList.remove('value-changed');
            // Force reflow
            void el.offsetWidth;
            el.classList.add('value-changed');
            setTimeout(() => el.classList.remove('value-changed'), 500);
        }

        // --- Helper: Update delta indicator ---
        function updateDelta(elementId, currentValue, previousValue, lowerIsBetter = true) {
            const deltaEl = document.getElementById(elementId);
            if (!deltaEl || previousValue === null || previousValue === undefined) {
                deltaEl.textContent = '';
                deltaEl.className = 'delta-indicator';
                return;
            }

            const diff = currentValue - previousValue;
            if (Math.abs(diff) < 0.001) {
                deltaEl.textContent = '‚Üí';
                deltaEl.className = 'delta-indicator';
                return;
            }

            const isUp = diff > 0;
            const isGood = lowerIsBetter ? !isUp : isUp;

            if (isUp) {
                deltaEl.textContent = '‚Üë';
                deltaEl.className = 'delta-indicator delta-up ' + (isGood ? 'good' : 'bad');
            } else {
                deltaEl.textContent = '‚Üì';
                deltaEl.className = 'delta-indicator delta-down ' + (isGood ? 'good' : 'bad');
            }
        }

        // --- Helper: Calculate system health ---
        function updateSystemHealth(data, gpuTemp, throughput, ramPercent, trainingMemGB) {
            const healthDot = document.getElementById('healthDot');
            const healthLabel = document.getElementById('healthLabel');

            let health = 'good';
            let label = 'ALL SYSTEMS NOMINAL';

            // Check for errors/crashes
            if (data.status === 'crashed') {
                health = 'error';
                label = 'SYSTEM ERROR';
            } else if (data.status === 'idle') {
                health = 'warning';
                label = 'IDLE - WAITING FOR DATA';
            } else if (data.status === 'training') {
                // Check RAM first (most critical)
                if (ramPercent > LIMITS.RAM_DANGER) {
                    health = 'error';
                    label = 'RAM CRITICAL - OOM RISK!';
                } else if (trainingMemGB > LIMITS.TRAINING_MEM_DANGER) {
                    health = 'error';
                    label = 'MEMORY LEAK DETECTED!';
                } else if (ramPercent > LIMITS.RAM_WARN) {
                    health = 'warning';
                    label = 'RAM USAGE HIGH';
                } else if (trainingMemGB > LIMITS.TRAINING_MEM_WARN) {
                    health = 'warning';
                    label = 'TRAINING MEM HIGH';
                } else if (gpuTemp > LIMITS.GPU_TEMP_DANGER) {
                    health = 'error';
                    label = 'GPU OVERHEATING!';
                } else if (gpuTemp > LIMITS.GPU_TEMP_HOT) {
                    health = 'warning';
                    label = 'GPU TEMPERATURE HIGH';
                } else if (lossHistory.length > 20) {
                    // Check if loss is increasing (bad)
                    const recent = lossHistory.slice(-10);
                    const prevWindow = lossHistory.slice(-20, -10);
                    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    const prevAvg = prevWindow.reduce((a, b) => a + b, 0) / prevWindow.length;

                    if (recentAvg > prevAvg * 1.1) {
                        health = 'warning';
                        label = 'LOSS INCREASING';
                    } else {
                        health = 'good';
                        label = 'TRAINING IN PROGRESS';
                    }
                }
            } else if (data.status === 'completed') {
                health = 'good';
                label = 'BATCH COMPLETED';
            }

            healthDot.className = 'health-dot status-' + health;
            healthLabel.textContent = label;
        }

        // --- Helper: Update persistent status bar ---
        function updateStatusBar(data, gpuTemp, throughputValue, ramUsed, ramPercent, trainingMemGB) {
            // Status
            const summaryStatus = document.getElementById('summaryStatus');
            summaryStatus.textContent = data.status.toUpperCase();
            if (previousValues.status !== data.status) {
                animateValueChange('summaryStatus');
                previousValues.status = data.status;
            }

            // Loss
            const lossValue = document.getElementById('lossValue');
            const currentLoss = data.loss;
            lossValue.textContent = currentLoss.toFixed(4);
            updateDelta('lossDelta', currentLoss, previousValues.loss, true);
            if (previousValues.loss !== null && Math.abs(currentLoss - previousValues.loss) > 0.001) {
                animateValueChange('lossValue');
            }
            previousValues.loss = currentLoss;

            // Progress
            const progressValue = document.getElementById('progressValue');
            const currentProgress = (data.current_step / data.total_steps * 100);
            progressValue.textContent = currentProgress.toFixed(1) + '%';
            if (previousValues.progress !== null && Math.abs(currentProgress - previousValues.progress) > 0.1) {
                animateValueChange('progressValue');
            }
            previousValues.progress = currentProgress;

            // GPU Temp
            const gpuValue = document.getElementById('gpuValue');
            gpuValue.textContent = gpuTemp.toFixed(0) + '¬∞C';
            updateDelta('gpuDelta', gpuTemp, previousValues.gpuTemp, true);
            if (previousValues.gpuTemp !== null && Math.abs(gpuTemp - previousValues.gpuTemp) > 1) {
                animateValueChange('gpuValue');
            }
            previousValues.gpuTemp = gpuTemp;

            // Throughput
            const throughputValueEl = document.getElementById('throughputValue');
            if (throughputValue && throughputValue > 0) {
                throughputValueEl.textContent = throughputValue.toFixed(1) + ' MB/hr';
                updateDelta('throughputDelta', throughputValue, previousValues.throughput, false);
                if (previousValues.throughput !== null && Math.abs(throughputValue - previousValues.throughput) > 0.5) {
                    animateValueChange('throughputValue');
                }
                previousValues.throughput = throughputValue;
            } else {
                throughputValueEl.textContent = '-- MB/hr';
            }

            // RAM
            const ramValueEl = document.getElementById('ramValue');
            ramValueEl.textContent = ramUsed.toFixed(1) + ' GB';
            updateDelta('ramDelta', ramUsed, previousValues.ramUsed, true);
            if (previousValues.ramUsed !== null && Math.abs(ramUsed - previousValues.ramUsed) > 0.5) {
                animateValueChange('ramValue');
            }
            previousValues.ramUsed = ramUsed;

            // Color code RAM based on risk
            if (ramPercent > LIMITS.RAM_DANGER) {
                ramValueEl.style.color = '#ff4444';
            } else if (ramPercent > LIMITS.RAM_WARN) {
                ramValueEl.style.color = '#ffaa00';
            } else {
                ramValueEl.style.color = '#00ff88';
            }

            // Queue
            const queueValueEl = document.getElementById('queueValue');
            const queueSize = data.batch_queue_size;
            if (queueSize !== null && queueSize !== undefined) {
                queueValueEl.textContent = queueSize + ' files';
                // Color code based on queue size
                if (queueSize === 0) {
                    queueValueEl.style.color = '#ff4444';
                } else if (queueSize < 5) {
                    queueValueEl.style.color = '#ffaa00';
                } else {
                    queueValueEl.style.color = '#00ff88';
                }
            } else {
                queueValueEl.textContent = '-';
                queueValueEl.style.color = '#888';
            }

            // Update system health
            updateSystemHealth(data, gpuTemp, throughputValue, ramPercent, trainingMemGB);
        }

        function exportTrainingData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                status: document.getElementById('status').textContent,
                progress: document.getElementById('progressPercent').textContent,
                currentStep: document.getElementById('currentStep').textContent,
                totalSteps: document.getElementById('totalSteps').textContent,
                loss: document.getElementById('currentLoss').textContent,
                learningRate: document.getElementById('learningRate').textContent,
                accuracy: document.getElementById('accuracyPercent').textContent,
                accuracyLast20: document.getElementById('accuracy20').textContent,
                accuracyLast50: document.getElementById('accuracy50').textContent,
                accuracyTrend: document.getElementById('accuracyTrend').textContent,
                gpuTemp: document.getElementById('gpuTemp').textContent,
                gpuMemory: document.getElementById('gpuMemUsed').textContent,
                systemRAM: document.getElementById('ramUsed').textContent,
                trainingProcessRAM: document.getElementById('trainingRAM').textContent,
                oomRisk: document.getElementById('oomRisk').textContent,
                lossHistory: lossHistory,
                accuracyHistory: accuracyHistory,
                trainingDuration: document.getElementById('trainingTimer').textContent,
                eta: document.getElementById('etaRemaining').textContent
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `training_snapshot_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateTrainingStats(data) {
            lastUpdateTime = Date.now();

            // Status
            const statusEl = document.getElementById('status');
            statusEl.textContent = data.status.toUpperCase();
            statusEl.className = 'metric-value status-' + data.status;

            // Check for completion and play sound
            if (data.status === 'completed' && !hasCompletedBefore) {
                hasCompletedBefore = true;
                playCompletionSound();

                // Record throughput for this batch
                if (currentFileStartTime && currentFileSizeMB > 0) {
                    const timeElapsedHours = (Date.now() - currentFileStartTime) / (1000 * 3600);
                    throughputHistory.push({
                        mb: currentFileSizeMB,
                        hours: timeElapsedHours
                    });

                    // Keep only last 10 batches
                    if (throughputHistory.length > 10) {
                        throughputHistory.shift();
                    }

                    console.log(`Batch completed: ${currentFileSizeMB.toFixed(1)} MB in ${(timeElapsedHours * 60).toFixed(1)} minutes`);
                    console.log(`Throughput: ${(currentFileSizeMB / timeElapsedHours).toFixed(1)} MB/hr`);
                }

                // Reset for next file
                currentFileStartTime = null;
                currentFileSizeMB = 0;
            } else if (data.status === 'training') {
                hasCompletedBefore = false;

                // Start tracking if new file
                if (!currentFileStartTime) {
                    currentFileStartTime = Date.now();
                    if (data.current_file_size_mb) {
                        currentFileSizeMB = data.current_file_size_mb;
                    } else {
                        currentFileSizeMB = 40; // Default estimate
                    }
                }
            }

            // Steps
            document.getElementById('currentStep').textContent = data.current_step.toLocaleString();
            document.getElementById('totalSteps').textContent = data.total_steps.toLocaleString();
            document.getElementById('epoch').textContent = data.epoch;

            // Progress with ARIA
            const progress = (data.current_step / data.total_steps * 100);
            const progressPercent = progress.toFixed(1) + '%';
            document.getElementById('progressPercent').textContent = progressPercent;
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = progressPercent;
            progressBar.textContent = progressPercent;

            const progressContainer = document.getElementById('progressContainer');
            progressContainer.setAttribute('aria-valuenow', Math.round(progress));

            // Overall Progress Bar with ARIA
            const overallProgressBar = document.getElementById('overallProgressBar');
            const overallProgressText = document.getElementById('overallProgressText');
            const overallProgressLabel = document.getElementById('overallProgressLabel');
            const overallProgressContainer = document.getElementById('overallProgressContainer');

            overallProgressBar.style.width = progressPercent;
            overallProgressText.textContent = progressPercent;
            overallProgressLabel.textContent = progressPercent;
            overallProgressContainer.setAttribute('aria-valuenow', Math.round(progress));

            // Pinned header values (removed - elements don't exist)
            // document.getElementById('pinnedProgress').textContent = progressPercent;

            // Config parameters
            document.getElementById('maxOutputTokens').textContent = data.max_output_tokens || 2048;
            document.getElementById('contextWindow').textContent = data.context_window || 2048;

            // Loss - with color coding
            const lossEl = document.getElementById('currentLoss');
            lossEl.textContent = data.loss.toFixed(4);
            document.getElementById('learningRate').textContent = data.learning_rate.toExponential(3);
            // document.getElementById('pinnedLoss').textContent = data.loss.toFixed(4);

            // Track loss history
            lossHistory.push(data.loss);
            if (lossHistory.length > 50) lossHistory.shift();

            // Draw sparkline
            drawLossSparkline(lossHistory);

            // Loss trend - with guarded calculation
            if (lossHistory.length >= 20) {
                const recent = lossHistory.slice(-10);
                const avg = recent.reduce((a, b) => a + b, 0) / recent.length;

                const prevWindow = lossHistory.slice(-20, -10);
                const prevAvg = prevWindow.length ? (prevWindow.reduce((a, b) => a + b, 0) / prevWindow.length) : avg;

                const lossTrendEl = document.getElementById('lossTrend');
                if (avg < prevAvg) {
                    lossTrendEl.textContent = '‚Üì Decreasing';
                    lossTrendEl.className = 'metric-value success';
                    lossEl.style.color = '#00ff88';
                    // document.getElementById('pinnedLoss').style.color = '#00ff88';
                } else if (avg > prevAvg) {
                    lossTrendEl.textContent = '‚Üë Increasing';
                    lossTrendEl.className = 'metric-value danger';
                    lossEl.style.color = '#ff4444';
                    // document.getElementById('pinnedLoss').style.color = '#ff4444';
                } else {
                    lossTrendEl.textContent = '‚Üí Stable';
                    lossTrendEl.className = 'metric-value';
                    lossEl.style.color = '#ffaa00';
                    // document.getElementById('pinnedLoss').style.color = '#ffaa00';
                }
            }

            // Speed calculations (server time only, with EMA)
            const currentTimestamp = new Date(data.timestamp).getTime();

            if (!startStep) {
                startStep = data.current_step;
                startTime = currentTimestamp;
            }

            if (!trainingStartTime && data.status === 'training') {
                trainingStartTime = Date.now();
            }

            if (lastTimestamp && data.current_step > lastStep) {
                const timeDiffSec = (currentTimestamp - lastTimestamp) / 1000;
                const stepDiff = data.current_step - lastStep;
                const spsInstant = stepDiff / Math.max(0.001, timeDiffSec);
                stepsPerSecEMA = stepsPerSecEMA == null ? spsInstant : (EMA_ALPHA * spsInstant + (1 - EMA_ALPHA) * stepsPerSecEMA);

                const stepsPerSec = stepsPerSecEMA;
                const examplesPerSec = stepsPerSec * EFFECTIVE_BATCH_SIZE;

                document.getElementById('stepsPerSec').textContent = stepsPerSec.toFixed(2);
                document.getElementById('examplesPerSec').textContent = examplesPerSec.toFixed(1);

                const stepsRemaining = Math.max(0, data.total_steps - data.current_step);
                const secondsRemaining = stepsRemaining / Math.max(0.0001, stepsPerSec);

                document.getElementById('etaRemaining').textContent = formatTime(secondsRemaining);
                document.getElementById('etaTime').textContent = new Date(currentTimestamp + secondsRemaining * 1000).toLocaleTimeString();
                document.getElementById('etaCountdown').textContent = formatTimeHHMMSS(secondsRemaining);
                // document.getElementById('pinnedETA').textContent = formatTime(secondsRemaining);
            }

            // Time elapsed
            if (startTime) {
                const elapsed = (currentTimestamp - startTime) / 1000;
                document.getElementById('timeElapsed').textContent = formatTime(elapsed);
            }

            // Training timer
            if (trainingStartTime) {
                const elapsed = (Date.now() - trainingStartTime) / 1000;
                document.getElementById('trainingTimer').textContent = formatTimeHHMMSS(elapsed);
            }

            lastStep = data.current_step;
            lastTimestamp = currentTimestamp;

            // Running accuracy
            if (data.total_evals !== undefined) {
                const overallAccuracy = data.accuracy_percent;
                document.getElementById('accuracyPercent').textContent = overallAccuracy.toFixed(1) + '%';
                document.getElementById('accuracyFraction').textContent = `${data.total_correct} / ${data.total_evals}`;

                // Track accuracy history for trend analysis
                // Update history from recent examples
                if (data.recent_examples && data.recent_examples.length > 0) {
                    data.recent_examples.forEach(ex => {
                        // Check if this step already exists in history
                        const existsIndex = accuracyHistory.findIndex(h => h.step === ex.step);
                        if (existsIndex === -1) {
                            // Add new entry
                            accuracyHistory.push({
                                step: ex.step,
                                correct: ex.matches
                            });
                        }
                    });

                    // Keep only last 100 entries
                    if (accuracyHistory.length > 100) {
                        accuracyHistory = accuracyHistory.slice(-100);
                    }

                    // Sort by step (should already be sorted, but just in case)
                    accuracyHistory.sort((a, b) => a.step - b.step);
                }

                // Calculate trend metrics
                updateAccuracyTrends(overallAccuracy);
            }

            // Current example (with sanitization)
            if (data.current_prompt) {
                document.getElementById('currentExampleStep').textContent = data.current_step.toLocaleString();
                document.getElementById('systemPrompt').textContent = data.current_system_prompt || '(No system prompt)';
                document.getElementById('prompt').textContent = data.current_prompt;
                document.getElementById('golden').textContent = data.golden_answer || 'N/A';
                document.getElementById('modelAnswer').textContent = data.model_answer || 'N/A';

                const matchBadge = document.getElementById('matchBadge');
                if (data.answer_matches !== null) {
                    matchBadge.className = data.answer_matches ? 'match-badge match-yes' : 'match-badge match-no';
                    matchBadge.textContent = data.answer_matches ? ' MATCH ‚úì' : ' NO MATCH ‚úó';
                } else {
                    matchBadge.className = '';
                    matchBadge.textContent = '';
                }
            }

            // Recent examples (with sanitization) - ONLY SHOW ACTUAL EVALS (with model output)
            if (data.recent_examples && data.recent_examples.length > 0) {
                const recentDiv = document.getElementById('recentExamples');
                let html = '';

                // Filter to only show examples with actual model output (evals, not just log steps)
                const evalExamples = data.recent_examples.filter(ex => ex.model_output !== null && ex.model_output !== undefined);

                if (evalExamples.length > 0) {
                    evalExamples.slice().reverse().forEach(ex => {
                        const matchIcon = ex.matches ? '‚úÖ' : '‚ùå';
                        const matchClass = ex.matches ? 'success' : 'danger';

                        html += `
                            <div style="border-bottom: 1px solid #2a3f5f; padding: 10px 0; margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <strong>Step ${Number(ex.step).toLocaleString()}</strong>
                                    <span class="${matchClass}">${matchIcon} ${ex.matches ? 'Match' : 'No Match'} | Loss: ${Number(ex.loss).toFixed(4)}</span>
                                </div>
                                <div style="font-size: 0.9em; color: #aaa;">
                                    ${ex.system_prompt ? `<div style="color: #88ccff;"><strong>System:</strong> ${escapeHTML(ex.system_prompt)}</div>` : ''}
                                    <div><strong>User:</strong> ${escapeHTML(ex.prompt)}</div>
                                    <div><strong>Expected:</strong> ${escapeHTML(ex.golden)}</div>
                                    <div><strong>Got:</strong> ${escapeHTML(ex.model_output)}</div>
                                </div>
                            </div>
                        `;
                    });
                    recentDiv.innerHTML = html;
                } else {
                    recentDiv.innerHTML = '<p style="color: #888;">No model evaluations yet (waiting for next eval step)...</p>';
                }
            }

            // Errors (with sanitization)
            const errorContainer = document.getElementById('errorContainer');
            if (data.status === 'crashed') {
                errorContainer.innerHTML = `
                    <div class="error-panel">
                        <h2>‚ö†Ô∏è Training Crashed!</h2>
                        <div class="metric">
                            <span class="metric-label">Error Type</span>
                            <span class="metric-value">${escapeHTML(data.error_type || 'Unknown')}</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Error Message</span>
                            <span class="metric-value">${escapeHTML(data.error_message || 'No details')}</span>
                        </div>
                    </div>
                `;
            } else {
                errorContainer.innerHTML = '';
            }
        }

        function updateAccuracyTrends(overallAccuracy) {
            if (accuracyHistory.length === 0) {
                document.getElementById('accuracy20').textContent = '-% (-/-)';
                document.getElementById('accuracy50').textContent = '-% (-/-)';
                document.getElementById('accuracyTrend').textContent = 'Insufficient data';
                return;
            }

            // Last 20 evaluations
            const last20 = accuracyHistory.slice(-20);
            const correct20 = last20.filter(h => h.correct).length;
            const accuracy20 = (correct20 / last20.length) * 100;

            const accuracy20El = document.getElementById('accuracy20');
            accuracy20El.textContent = `${accuracy20.toFixed(1)}% (${correct20}/${last20.length})`;

            // Color code based on comparison to overall
            if (last20.length >= 10) { // Only color if we have enough data
                if (accuracy20 > overallAccuracy + 5) {
                    accuracy20El.className = 'metric-value success';
                } else if (accuracy20 < overallAccuracy - 5) {
                    accuracy20El.className = 'metric-value danger';
                } else {
                    accuracy20El.className = 'metric-value';
                }
            }

            // Last 50 evaluations
            if (accuracyHistory.length >= 50) {
                const last50 = accuracyHistory.slice(-50);
                const correct50 = last50.filter(h => h.correct).length;
                const accuracy50 = (correct50 / last50.length) * 100;

                const accuracy50El = document.getElementById('accuracy50');
                accuracy50El.textContent = `${accuracy50.toFixed(1)}% (${correct50}/${last50.length})`;

                // Color code
                if (accuracy50 > overallAccuracy + 3) {
                    accuracy50El.className = 'metric-value success';
                } else if (accuracy50 < overallAccuracy - 3) {
                    accuracy50El.className = 'metric-value danger';
                } else {
                    accuracy50El.className = 'metric-value';
                }
            } else {
                const currentLength = accuracyHistory.length;
                const correct = accuracyHistory.filter(h => h.correct).length;
                const accuracy = (correct / currentLength) * 100;
                document.getElementById('accuracy50').textContent = `${accuracy.toFixed(1)}% (${correct}/${currentLength})`;
            }

            // Trend analysis (use last 20 vs overall)
            if (last20.length >= 10) {
                const diff = accuracy20 - overallAccuracy;
                const trendEl = document.getElementById('accuracyTrend');

                if (Math.abs(diff) < 3) {
                    trendEl.textContent = '‚Üí Stable';
                    trendEl.className = 'metric-value';
                } else if (diff > 0) {
                    trendEl.textContent = `‚Üë Improving (+${diff.toFixed(1)}%)`;
                    trendEl.className = 'metric-value success';
                } else {
                    trendEl.textContent = `‚Üì Regressing (${diff.toFixed(1)}%)`;
                    trendEl.className = 'metric-value danger';
                }
            } else {
                document.getElementById('accuracyTrend').textContent = 'Collecting data...';
                document.getElementById('accuracyTrend').className = 'metric-value';
            }
        }

        function updateMemoryStats(mem) {
            if (mem.error) {
                document.getElementById('ramStatus').textContent = 'Error loading RAM stats';
                return;
            }

            document.getElementById('ramStatus').textContent = `${mem.used_gb.toFixed(1)} GB / ${mem.total_gb.toFixed(1)} GB (${mem.percent.toFixed(0)}%)`;

            // RAM used
            const ramPercent = mem.percent;
            document.getElementById('ramUsed').textContent = `${mem.used_gb.toFixed(1)} GB`;
            document.getElementById('ramLabel').textContent = `${mem.used_gb.toFixed(1)} GB / ${mem.total_gb.toFixed(1)} GB (${ramPercent.toFixed(0)}%)`;
            document.getElementById('ramGauge').style.width = ramPercent + '%';
            document.getElementById('ramGaugeWrap').setAttribute('aria-valuenow', ramPercent.toFixed(0));

            const ramUsedEl = document.getElementById('ramUsed');
            if (ramPercent > LIMITS.RAM_DANGER) {
                ramUsedEl.className = 'stat-card-value danger';
                ramUsedEl.style.animation = 'flash 1s infinite';
            } else if (ramPercent > LIMITS.RAM_WARN) {
                ramUsedEl.className = 'stat-card-value warning';
                ramUsedEl.style.animation = '';
            } else {
                ramUsedEl.className = 'stat-card-value success';
                ramUsedEl.style.animation = '';
            }

            // Training process memory
            const trainingMemGB = mem.training_process_gb;
            document.getElementById('trainingRAM').textContent = `${trainingMemGB.toFixed(1)} GB`;
            document.getElementById('trainingRAMLabel').textContent = `${trainingMemGB.toFixed(1)} GB`;
            const trainingMemPercent = (trainingMemGB / mem.total_gb) * 100;
            document.getElementById('trainingRAMGauge').style.width = trainingMemPercent + '%';
            document.getElementById('trainingRAMGaugeWrap').setAttribute('aria-valuenow', trainingMemPercent.toFixed(0));

            const trainingRAMEl = document.getElementById('trainingRAM');
            if (trainingMemGB > LIMITS.TRAINING_MEM_DANGER) {
                trainingRAMEl.className = 'stat-card-value danger';
                trainingRAMEl.style.animation = 'flash 1s infinite';
            } else if (trainingMemGB > LIMITS.TRAINING_MEM_WARN) {
                trainingRAMEl.className = 'stat-card-value warning';
                trainingRAMEl.style.animation = '';
            } else {
                trainingRAMEl.className = 'stat-card-value success';
                trainingRAMEl.style.animation = '';
            }

            // Available RAM
            document.getElementById('ramAvailable').textContent = `${mem.available_gb.toFixed(1)} GB`;

            // OOM Risk
            const oomRiskEl = document.getElementById('oomRisk');
            oomRiskEl.textContent = mem.oom_risk.toUpperCase();
            if (mem.oom_risk === 'high') {
                oomRiskEl.className = 'stat-card-value danger';
            } else if (mem.oom_risk === 'medium') {
                oomRiskEl.className = 'stat-card-value warning';
            } else {
                oomRiskEl.className = 'stat-card-value success';
            }

            // Swap usage
            const swapPercent = mem.swap_percent;
            document.getElementById('swapLabel').textContent = `${mem.swap_used_gb.toFixed(2)} GB / ${mem.swap_total_gb.toFixed(1)} GB (${swapPercent.toFixed(0)}%)`;
            document.getElementById('swapGauge').style.width = swapPercent + '%';
            document.getElementById('swapGaugeWrap').setAttribute('aria-valuenow', swapPercent.toFixed(0));
        }

        function updateGPUStats(gpu) {
            if (gpu.error) {
                document.getElementById('gpuName').textContent = 'Error loading GPU stats';
                return;
            }

            document.getElementById('gpuName').textContent = gpu.gpu_name;

            // Temperature with warning
            const tempPercent = (gpu.temperature / LIMITS.GPU_TEMP_DANGER) * 100;
            document.getElementById('gpuTemp').textContent = `${gpu.temperature.toFixed(0)}¬∞C`;
            document.getElementById('tempLabel').textContent = `${gpu.temperature.toFixed(0)}¬∞C / ${LIMITS.GPU_TEMP_DANGER}¬∞C`;
            document.getElementById('tempGauge').style.width = Math.min(tempPercent, 100) + '%';
            // document.getElementById('pinnedGPU').textContent = `${gpu.temperature.toFixed(0)}¬∞C`;
            document.getElementById('tempGaugeWrap').setAttribute('aria-valuenow', Math.min(100, Math.max(0, tempPercent)).toFixed(0));

            const tempEl = document.getElementById('gpuTemp');
            // const pinnedGPU = document.getElementById('pinnedGPU');
            if (gpu.temperature > LIMITS.GPU_TEMP_HOT) {
                tempEl.className = 'stat-card-value danger';
                // pinnedGPU.style.color = '#ff4444';
                if (gpu.temperature > LIMITS.GPU_TEMP_DANGER) {
                    tempEl.style.animation = 'flash 1s infinite';
                }
            } else if (gpu.temperature > LIMITS.GPU_TEMP_WARN) {
                tempEl.className = 'stat-card-value warning';
                // pinnedGPU.style.color = '#ffaa00';
            } else {
                tempEl.className = 'stat-card-value success';
                // pinnedGPU.style.color = '#00ff88';
                tempEl.style.animation = '';
            }

            // GPU Utilization
            document.getElementById('gpuUtilPercent').textContent = `${gpu.gpu_utilization.toFixed(0)}%`;
            document.getElementById('utilLabel').textContent = `${gpu.gpu_utilization.toFixed(0)}%`;
            document.getElementById('utilGauge').style.width = gpu.gpu_utilization + '%';
            document.getElementById('utilGaugeWrap').setAttribute('aria-valuenow', gpu.gpu_utilization.toFixed(0));

            // Memory
            const memUsedGB = (gpu.memory_used_mb / 1024).toFixed(1);
            const memTotalGB = (gpu.memory_total_mb / 1024).toFixed(1);
            const memPercent = (gpu.memory_used_mb / gpu.memory_total_mb * 100).toFixed(0);
            document.getElementById('gpuMemUsed').textContent = `${memUsedGB} GB`;
            document.getElementById('memLabel').textContent = `${memUsedGB} GB / ${memTotalGB} GB (${memPercent}%)`;
            document.getElementById('memGauge').style.width = memPercent + '%';
            document.getElementById('memGaugeWrap').setAttribute('aria-valuenow', memPercent);

            // Power
            const powerPercent = (gpu.power_draw_w / gpu.power_limit_w * 100).toFixed(0);
            document.getElementById('gpuPower').textContent = `${gpu.power_draw_w.toFixed(0)} W`;
            document.getElementById('powerLabel').textContent = `${gpu.power_draw_w.toFixed(0)} W / ${gpu.power_limit_w.toFixed(0)} W`;
            document.getElementById('powerGauge').style.width = powerPercent + '%';
            document.getElementById('powerGaugeWrap').setAttribute('aria-valuenow', powerPercent);
        }

        // --- Non-overlapping polling with visibility throttle ---
        async function poll() {
            if (inFlight || isPaused) return;
            inFlight = true;

            try {
                await fetchStatus();
                errorCount = 0; // Reset on success
                currentBackoff = 0;
            } catch (error) {
                errorCount++;
                currentBackoff = Math.min(LIMITS.MAX_BACKOFF_MS, BASE_REFRESH_MS * Math.pow(2, errorCount));
                console.error(`Fetch failed (${errorCount}/${LIMITS.MAX_ERROR_RETRIES}), backing off ${currentBackoff}ms`);
            } finally {
                inFlight = false;
                const factor = document.hidden ? 3 : 1; // throttle on background tab
                const delay = currentBackoff || (BASE_REFRESH_MS * factor);
                pollTimer = setTimeout(poll, delay);
            }
        }

        async function fetchStatus() {
            const refreshStatus = document.getElementById('refreshStatus');
            let trainingData = null;
            let gpuData = null;
            let memoryData = null;
            let throughputValue = null;

            try {
                refreshStatus.classList.add('pulse');

                // Fetch training status
                const statusResponse = await fetch(STATUS_FILE + '?t=' + Date.now());
                if (statusResponse.ok) {
                    trainingData = await statusResponse.json();
                    updateTrainingStats(trainingData);

                    // NEW: Update advanced metrics displays
                    if (typeof MetricsUpdater !== 'undefined') {
                        MetricsUpdater.updateFixedEval(trainingData);
                        MetricsUpdater.updateStreamingMetrics(trainingData);
                        MetricsUpdater.updateThroughput(trainingData);
                        MetricsUpdater.updateLayerActivity(trainingData);
                        MetricsUpdater.updateAlerts(trainingData);
                    }

                    refreshStatus.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
                } else {
                    refreshStatus.textContent = 'No training data';
                }

                // Fetch GPU stats
                const gpuResponse = await fetch(GPU_STATS_API + '?t=' + Date.now());
                if (gpuResponse.ok) {
                    gpuData = await gpuResponse.json();
                    updateGPUStats(gpuData);
                }

                // Fetch memory stats
                const memoryResponse = await fetch(MEMORY_STATS_API + '?t=' + Date.now());
                if (memoryResponse.ok) {
                    memoryData = await memoryResponse.json();
                    updateMemoryStats(memoryData);
                }

                // Fetch inbox files
                const inboxResponse = await fetch(INBOX_FILES_API + '?t=' + Date.now());
                if (inboxResponse.ok) {
                    const inboxData = await inboxResponse.json();
                    updateInboxFiles(inboxData);
                }

                // Update persistent status bar with all collected data
                if (trainingData) {
                    const gpuTemp = (gpuData && gpuData.temperature) ? gpuData.temperature : 0;
                    const ramUsed = (memoryData && memoryData.used_gb) ? memoryData.used_gb : 0;
                    const ramPercent = (memoryData && memoryData.percent) ? memoryData.percent : 0;
                    const trainingMemGB = (memoryData && memoryData.training_process_gb) ? memoryData.training_process_gb : 0;
                    throughputValue = calculateThroughput();
                    updateStatusBar(trainingData, gpuTemp, throughputValue, ramUsed, ramPercent, trainingMemGB);
                }
            } catch (error) {
                refreshStatus.textContent = 'Error loading data';
                console.error('Failed to fetch data:', error);
                throw error; // Re-throw to trigger backoff
            } finally {
                refreshStatus.classList.remove('pulse');
            }
        }

        function calculateThroughput() {
            if (throughputHistory.length === 0) return null;

            // Use recent batches for better accuracy (last 5)
            const recentBatches = throughputHistory.slice(-5);
            const totalMB = recentBatches.reduce((sum, b) => sum + b.mb, 0);
            const totalTimeHours = recentBatches.reduce((sum, b) => sum + b.hours, 0);

            if (totalTimeHours === 0) return null;
            return totalMB / totalTimeHours; // MB per hour
        }

        function updateInboxFiles(data) {
            const filesIndicator = document.getElementById('filesIndicator');
            const filesCount = document.getElementById('filesCount');
            const filesListContainer = document.getElementById('filesListContainer');

            if (data.count > 0) {
                filesCount.textContent = data.count;
                filesIndicator.style.display = 'block';

                // Update queue estimator
                const queueEstimator = document.getElementById('queueEstimator');
                const throughputMBPerHour = calculateThroughput();

                if (throughputMBPerHour && throughputMBPerHour > 0) {
                    queueEstimator.style.display = 'block';

                    // Calculate total queued size
                    const totalQueuedMB = data.files.reduce((sum, f) => sum + f.size_mb, 0);

                    // Estimate time
                    const hoursRemaining = totalQueuedMB / throughputMBPerHour;
                    const secondsRemaining = hoursRemaining * 3600;

                    // Update display
                    document.getElementById('queueCount').textContent = data.count;
                    document.getElementById('queueSize').textContent = totalQueuedMB.toFixed(1) + ' MB';
                    document.getElementById('queueETA').textContent = formatTimeHHMMSS(secondsRemaining);

                    const completionDate = new Date(Date.now() + secondsRemaining * 1000);
                    document.getElementById('queueCompleteTime').textContent = completionDate.toLocaleString();

                    // NEW: Populate detailed file list
                    const filesHTML = data.files.map((file, idx) => {
                        const fileTimeEstimate = throughputMBPerHour > 0 ? (file.size_mb / throughputMBPerHour) * 3600 : 0;
                        const estimatedExamples = Math.round((file.size_mb / 40) * 10000); // ~40MB = 10k examples

                        return `
                            <div style="background: rgba(42, 63, 95, 0.3); padding: 10px; margin-bottom: 8px; border-radius: 5px; border-left: 3px solid #00d9ff;">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 5px;">
                                    <div style="flex: 1;">
                                        <div style="color: #00ff88; font-weight: bold; margin-bottom: 3px;">
                                            ${idx + 1}. ${file.name}
                                        </div>
                                        <div style="color: #888; font-size: 0.85em;">
                                            Added: ${new Date(file.mtime * 1000).toLocaleString()}
                                        </div>
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="color: #00d9ff; font-size: 1.1em; font-weight: bold;">
                                            ${file.size_mb.toFixed(1)} MB
                                        </div>
                                        <div style="color: #888; font-size: 0.85em;">
                                            ~${estimatedExamples.toLocaleString()} examples
                                        </div>
                                    </div>
                                </div>
                                ${fileTimeEstimate > 0 ? `
                                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0, 217, 255, 0.2);">
                                        <div style="display: flex; justify-content: space-between; font-size: 0.9em;">
                                            <span style="color: #00d9ff;">‚è±Ô∏è Est. Training Time:</span>
                                            <span style="color: #00ff88; font-weight: bold;">${formatTimeHHMMSS(fileTimeEstimate)}</span>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('');

                    filesListContainer.innerHTML = filesHTML || '<div style="color: #888; text-align: center; padding: 20px;">No files in queue</div>';
                } else {
                    queueEstimator.style.display = 'none';
                }
            } else {
                filesIndicator.style.display = 'none';
                document.getElementById('queueEstimator').style.display = 'none';
                filesListContainer.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No files in queue</div>';
            }

            // Update throughput display
            const throughputMBPerHour = calculateThroughput();
            if (throughputMBPerHour && throughputMBPerHour > 0) {
                document.getElementById('throughput').textContent = throughputMBPerHour.toFixed(1) + ' MB/hr';
                const batchCount = Math.min(throughputHistory.length, 5);
                document.getElementById('throughputDetails').textContent = `Based on ${batchCount} batch${batchCount > 1 ? 'es' : ''}`;
            } else {
                document.getElementById('throughput').textContent = '-- MB/hr';
                document.getElementById('throughputDetails').textContent = 'No data yet';
            }
        }

        // Update "last update age" timer
        setInterval(() => {
            const ageSeconds = Math.floor((Date.now() - lastUpdateTime) / 1000);
            const ageEl = document.getElementById('lastUpdateAge');
            const labelEl = document.getElementById('lastUpdateLabel');

            if (!ageEl || !labelEl) return; // Guard against missing elements

            if (ageSeconds < 3) {
                ageEl.textContent = 'now';
                ageEl.style.color = '#00ff88';
            } else if (ageSeconds < LIMITS.STALE_DATA_SEC) {
                ageEl.textContent = `${ageSeconds}s ago`;
                ageEl.style.color = '#00ff88';
            } else {
                ageEl.textContent = `${ageSeconds}s ago`;
                ageEl.style.color = '#ff4444';
                labelEl.style.color = '#ff4444';
            }
        }, 1000);

        // Control button handlers
        document.getElementById('themeToggle').addEventListener('click', () => {
            darkTheme = !darkTheme;
            document.body.classList.toggle('theme-dark');
            document.body.classList.toggle('theme-light');
            document.getElementById('themeToggle').textContent = darkTheme ? 'üåô Dark' : '‚òÄÔ∏è Light';
            document.getElementById('themeToggle').setAttribute('aria-pressed', darkTheme);
            localStorage.setItem('tlm:darkTheme', darkTheme);
        });

        document.getElementById('compactToggle').addEventListener('click', () => {
            compactMode = !compactMode;
            document.body.classList.toggle('compact-mode');
            document.getElementById('compactToggle').textContent = compactMode ? 'üì¶ Normal' : 'üì¶ Compact';
            document.getElementById('compactToggle').setAttribute('aria-pressed', compactMode);
            localStorage.setItem('tlm:compactMode', compactMode);
        });

        document.getElementById('pauseToggle').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseToggle').textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            document.getElementById('pauseToggle').setAttribute('aria-pressed', isPaused);
            if (!isPaused && !inFlight) {
                clearTimeout(pollTimer);
                poll();
            }
        });

        document.getElementById('exportButton').addEventListener('click', exportTrainingData);

        document.getElementById('soundToggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? 'üîî Sound ON' : 'üîï Sound OFF';
            document.getElementById('soundToggle').setAttribute('aria-pressed', soundEnabled);
            localStorage.setItem('tlm:soundEnabled', soundEnabled);
        });

        // NEW: Files indicator toggle handler
        document.getElementById('filesIndicator').addEventListener('click', () => {
            const filesList = document.getElementById('queuedFilesList');
            const toggleIcon = document.getElementById('filesToggleIcon');
            const toggleBtn = document.getElementById('toggleFileDetailsBtn');

            if (filesList.style.display === 'none') {
                filesList.style.display = 'block';
                toggleIcon.textContent = '‚ñ≤';
                toggleBtn.textContent = 'üìã Hide Details';
            } else {
                filesList.style.display = 'none';
                toggleIcon.textContent = '‚ñº';
                toggleBtn.textContent = 'üìã Show Details';
            }
        });

        // NEW: Toggle file details button handler
        document.getElementById('toggleFileDetailsBtn').addEventListener('click', () => {
            const filesList = document.getElementById('queuedFilesList');
            const toggleIcon = document.getElementById('filesToggleIcon');
            const toggleBtn = document.getElementById('toggleFileDetailsBtn');

            if (filesList.style.display === 'none') {
                filesList.style.display = 'block';
                toggleIcon.textContent = '‚ñ≤';
                toggleBtn.textContent = 'üìã Hide Details';
            } else {
                filesList.style.display = 'none';
                toggleIcon.textContent = '‚ñº';
                toggleBtn.textContent = 'üìã Show Details';
            }
        });

        // Update button states
        document.getElementById('themeToggle').textContent = darkTheme ? 'üåô Dark' : '‚òÄÔ∏è Light';
        document.getElementById('themeToggle').setAttribute('aria-pressed', darkTheme);
        document.getElementById('compactToggle').textContent = compactMode ? 'üì¶ Normal' : 'üì¶ Compact';
        document.getElementById('compactToggle').setAttribute('aria-pressed', compactMode);
        document.getElementById('soundToggle').textContent = soundEnabled ? 'üîî Sound ON' : 'üîï Sound OFF';
        document.getElementById('soundToggle').setAttribute('aria-pressed', soundEnabled);

        // Resume immediately when the tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && !isPaused && !inFlight) {
                clearTimeout(pollTimer);
                poll();
            }
        });

        // Fetch config on load (only once)
        fetch(CONFIG_API).then(r => r.json()).then(config => {
            const batch = config.batch_size ?? '-';
            const accum = config.gradient_accumulation ?? '-';
            let effective = '-';
            if (!isNaN(batch) && !isNaN(accum)) {
                effective = (batch * accum).toString();
            }
            document.getElementById('batchSize').textContent = batch;
            document.getElementById('gradAccum').textContent = accum;
            document.getElementById('effectiveBatch').textContent = effective;
            document.getElementById('modelName').textContent = config.model_display_name || config.model_name || 'Qwen3 0.6B';
            if (window.MetricsUpdater) {
                MetricsUpdater.configBatchSize = config.batch_size || null;
                MetricsUpdater.configGradAccum = config.gradient_accumulation || null;
            }
        }).catch(e => console.error('Failed to load config:', e));

        // Queue Preview Functionality
        const INBOX_SAMPLES_API = '/api/inbox_samples';
        let queueSamplesTimer = null;

        async function fetchAndDisplayQueueSamples() {
            try {
                const response = await fetch(INBOX_SAMPLES_API + '?t=' + Date.now());
                if (!response.ok) return;

                const data = await response.json();
                const samples = data.samples || [];

                if (samples.length > 0) {
                    document.getElementById('toggleQueuePreview').style.display = 'block';
                    updateQueueSamples(samples);
                } else {
                    document.getElementById('toggleQueuePreview').style.display = 'none';
                }
            } catch (e) {
                console.error('Failed to fetch queue samples:', e);
            }
        }

        function updateQueueSamples(samples) {
            const container = document.getElementById('queueSamplesContainer');

            // HTML escape function to prevent breaking the page
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            const samplesHTML = samples.map(sample => {
                // Truncate long prompts/answers for preview
                const promptPreview = sample.prompt.length > 500 ? sample.prompt.substring(0, 500) + '...' : sample.prompt;
                const answerPreview = sample.answer.length > 300 ? sample.answer.substring(0, 300) + '...' : sample.answer;

                // Escape HTML to prevent breaking the page
                const safePrompt = escapeHtml(promptPreview);
                const safeAnswer = escapeHtml(answerPreview);
                const safeFilename = escapeHtml(sample.filename);

                return `
                    <div style="min-width: 400px; max-width: 500px; background: rgba(42, 63, 95, 0.3); border-radius: 8px; padding: 15px; border-left: 3px solid #00ff88;">
                        <div style="color: #00d9ff; font-weight: bold; margin-bottom: 8px; font-size: 0.95em;">
                            üìÅ ${safeFilename}
                        </div>
                        <div style="color: #888; font-size: 0.85em; margin-bottom: 10px;">
                            ${sample.total_lines.toLocaleString()} examples ‚Ä¢ Random sample
                        </div>

                        <div style="background: rgba(0, 0, 0, 0.3); border-radius: 5px; padding: 10px; margin-bottom: 8px;">
                            <div style="color: #ffaa00; font-size: 0.85em; margin-bottom: 5px; font-weight: bold;">PROMPT:</div>
                            <div style="color: #fff; font-size: 0.85em; max-height: 120px; overflow-y: auto; white-space: pre-wrap; font-family: monospace;">${safePrompt}</div>
                        </div>

                        <div style="background: rgba(0, 0, 0, 0.3); border-radius: 5px; padding: 10px;">
                            <div style="color: #00ff88; font-size: 0.85em; margin-bottom: 5px; font-weight: bold;">ANSWER:</div>
                            <div style="color: #fff; font-size: 0.85em; max-height: 80px; overflow-y: auto; white-space: pre-wrap; font-family: monospace;">${safeAnswer}</div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = samplesHTML;
        }

        // Queue Preview event listeners - WAIT FOR DOM
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('toggleQueuePreview');
            const closeBtn = document.getElementById('closeQueuePreview');
            const panel = document.getElementById('queuePreviewPanel');

            if (toggleBtn && panel) {
                toggleBtn.addEventListener('click', () => {
                    const show = panel.style.display !== 'block';
                    panel.style.display = show ? 'block' : 'none';
                    if (show) fetchAndDisplayQueueSamples();
                });
            }

            if (closeBtn && panel) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                });
            }

            // Safe to start sampling now that controls exist
            fetchAndDisplayQueueSamples();
            setInterval(fetchAndDisplayQueueSamples, 30000);
        });

        // Start polling
        poll();

        // Update training timer every second
        setInterval(() => {
            if (trainingStartTime) {
                const elapsed = (Date.now() - trainingStartTime) / 1000;
                document.getElementById('trainingTimer').textContent = formatTimeHHMMSS(elapsed);
            }
        }, 1000);

        // Close shortcuts modal function
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcutsModal');
            if (modal) modal.style.display = 'none';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // 'r' or 'R' to force refresh
            if (e.key === 'r' || e.key === 'R') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    fetchStatus();
                    console.log('Manual refresh triggered');
                }
            }
            // 'f' for fullscreen toggle
            if (e.key === 'f' || e.key === 'F') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                }
            }
            // 'c' for compact mode
            if (e.key === 'c' || e.key === 'C') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('compactToggle').click();
                }
            }
            // 't' for theme toggle
            if (e.key === 't' || e.key === 'T') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('themeToggle').click();
                }
            }
            // 'e' for export
            if (e.key === 'e' || e.key === 'E') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    exportTrainingData();
                }
            }
            // 'p' for pause/resume
            if (e.key === 'p' || e.key === 'P') {
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    document.getElementById('pauseToggle').click();
                }
            }
        });

        // Log keyboard shortcuts
        console.log('‚å®Ô∏è  KEYBOARD SHORTCUTS:');
        console.log('  R - Manual refresh');
        console.log('  F - Toggle fullscreen');
        console.log('  C - Toggle compact mode');
        console.log('  T - Toggle dark/light theme');
        console.log('  E - Export training data');
        console.log('  P - Pause/resume auto-refresh');
        console.log('  ? - Show keyboard shortcuts help');

        // ==================================================
        // TIER 1 UI/UX IMPROVEMENTS - Integration
        // ==================================================

        // Call velocity indicator on each update
        const originalFetchStatus = fetchStatus;
        fetchStatus = async function() {
            const result = await originalFetchStatus();
            // Update velocity if we have steps/sec
            if (stepsPerSecEMA) {
                updateVelocity(stepsPerSecEMA);
            }
            return result;
        };

        // Check for plateau every update
        if (typeof detectLossPlateau === 'function') {
            setInterval(() => {
                if (lossHistory.length > 0) {
                    detectLossPlateau(lossHistory);
                }
            }, 30000); // Check every 30 seconds
        }

        // Update confidence on each evaluation
        // This will be called from the updateTrainingStats function
        // We'll add the hook there

        // Show notifications for critical events
        function checkForCriticalEvents(data) {
            const previousStatus = lastStatusForNotification;

            // Training completed (only fire on transition)
            if (data.status === 'completed' && previousStatus !== 'completed') {
                sendNotification('Training Completed!', 'Training batch has finished successfully.', 'normal');
                playSound('complete');
            }

            // Training crashed (only fire on transition)
            if (data.status === 'crashed' && previousStatus !== 'crashed') {
                sendNotification('Training Crashed!', 'Training has stopped with an error.', 'urgent');
                showErrorBanner({ message: data.error || 'Training crashed', file: data.current_file });
                playSound('error');
            }

            // New best model (from smart monitor)
            if (data.best_model_updated) {
                sendNotification('New Best Model!', `Step ${data.current_step}: Loss ${data.loss.toFixed(4)}`, 'normal');
                playSound('bestModel');
            }

            lastStatusForNotification = data.status;
        }

        // Integrate with existing update function
        const originalUpdateTrainingStats = updateTrainingStats;
        updateTrainingStats = function(data) {
            originalUpdateTrainingStats(data);

            // Check for critical events
            checkForCriticalEvents(data);

            // Update confidence if we have loss for current example
            if (data.validation_example && data.validation_example.loss) {
                updateConfidence(data.validation_example.loss);
            }
        };

        console.log('‚úÖ Tier 1 improvements integrated');

        // ========================================
        // FLAGGED EXAMPLES PANEL
        // ========================================
        let flaggedData = null;
        let filteredFlagged = [];

        async function loadFlaggedExamples() {
            try {
                const response = await fetch('/api/flagged_examples?t=' + Date.now());
                if (response.ok) {
                    flaggedData = await response.json();
                    updateFlaggedStats();
                    applyFlaggedFilters();

                    // Update button badge
                    document.getElementById('flaggedCount').textContent = flaggedData.total;
                }
            } catch (error) {
                console.error('Failed to load flagged examples:', error);
            }
        }

        function updateFlaggedStats() {
            if (!flaggedData) return;

            document.getElementById('flaggedTotal').textContent = flaggedData.total;
            document.getElementById('flaggedMismatches').textContent = flaggedData.statistics.by_reason.mismatch || 0;
            document.getElementById('flaggedHighLoss').textContent = flaggedData.statistics.by_reason.high_loss || 0;
            document.getElementById('flaggedAvgLoss').textContent = flaggedData.statistics.avg_loss.toFixed(3);
        }

        function applyFlaggedFilters() {
            if (!flaggedData) return;

            const filter = document.getElementById('flaggedFilter').value;
            const sort = document.getElementById('flaggedSort').value;

            // Filter
            if (filter === 'all') {
                filteredFlagged = [...flaggedData.examples];
            } else {
                filteredFlagged = flaggedData.examples.filter(ex => ex.flag_reason === filter);
            }

            // Sort
            switch (sort) {
                case 'recent':
                    filteredFlagged.sort((a, b) => b.step - a.step);
                    break;
                case 'oldest':
                    filteredFlagged.sort((a, b) => a.step - b.step);
                    break;
                case 'highest_loss':
                    filteredFlagged.sort((a, b) => b.loss - a.loss);
                    break;
                case 'lowest_loss':
                    filteredFlagged.sort((a, b) => a.loss - b.loss);
                    break;
            }

            renderFlaggedExamples();
        }

        function renderFlaggedExamples() {
            const container = document.getElementById('flaggedExamplesList');

            if (filteredFlagged.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No flagged examples found</div>';
                return;
            }

            const html = filteredFlagged.map((ex, idx) => {
                const reasonColors = {
                    'mismatch': '#ff4444',
                    'high_loss': '#ffaa00',
                    'error': '#ff8844',
                    'manual': '#00d9ff'
                };
                const reasonColor = reasonColors[ex.flag_reason] || '#888';

                const matchBadge = ex.matches ?
                    '<span style="color: #00ff88;">‚úì Match</span>' :
                    '<span style="color: #ff4444;">‚úó No Match</span>';

                return `
                    <div style="background: rgba(42, 63, 95, 0.3); padding: 15px; margin-bottom: 10px; border-radius: 5px; border-left: 4px solid ${reasonColor};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <span style="color: #00d9ff; font-weight: bold;">Step ${ex.step.toLocaleString()}</span>
                                <span style="margin: 0 10px; color: #888;">|</span>
                                <span style="color: ${reasonColor}; font-size: 0.9em;">üö© ${ex.flag_reason.toUpperCase().replace('_', ' ')}</span>
                                ${ex.current_file ? `<span style="margin: 0 10px; color: #888;">|</span><span style="color: #888; font-size: 0.85em;">üìÅ ${ex.current_file}</span>` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffaa00; font-weight: bold;">Loss: ${ex.loss.toFixed(4)}</div>
                                <div style="font-size: 0.9em;">${matchBadge}</div>
                            </div>
                        </div>

                        ${ex.notes ? `<div style="background: rgba(0, 0, 0, 0.2); padding: 8px; border-radius: 3px; margin-bottom: 10px; color: #888; font-size: 0.9em; font-style: italic;">üí° ${ex.notes}</div>` : ''}

                        <div style="margin-bottom: 10px;">
                            <div style="color: #00d9ff; font-weight: bold; margin-bottom: 5px;">üìù Prompt:</div>
                            <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 3px; max-height: 150px; overflow-y: auto; font-size: 0.9em; white-space: pre-wrap; font-family: monospace;">${ex.prompt.substring(0, 500)}${ex.prompt.length > 500 ? '...' : ''}</div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <div style="color: #00ff88; font-weight: bold; margin-bottom: 5px;">‚úÖ Golden Answer:</div>
                                <div style="background: rgba(0, 255, 136, 0.1); padding: 10px; border-radius: 3px; max-height: 150px; overflow-y: auto; font-size: 0.9em; white-space: pre-wrap; font-family: monospace;">${ex.golden_answer.substring(0, 300)}${ex.golden_answer.length > 300 ? '...' : ''}</div>
                            </div>
                            <div>
                                <div style="color: ${ex.matches ? '#00ff88' : '#ff4444'}; font-weight: bold; margin-bottom: 5px;">ü§ñ Model Output:</div>
                                <div style="background: rgba(${ex.matches ? '0, 255, 136' : '255, 68, 68'}, 0.1); padding: 10px; border-radius: 3px; max-height: 150px; overflow-y: auto; font-size: 0.9em; white-space: pre-wrap; font-family: monospace;">${ex.model_output.substring(0, 300)}${ex.model_output.length > 300 ? '...' : ''}</div>
                            </div>
                        </div>

                        <div style="margin-top: 10px; color: #888; font-size: 0.85em;">
                            üïí ${new Date(ex.timestamp).toLocaleString()}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        // Event Listeners
        document.getElementById('viewFlaggedButton').addEventListener('click', () => {
            document.getElementById('flaggedPanel').style.display = 'flex';
            loadFlaggedExamples();
        });

        document.getElementById('closeFlaggedPanel').addEventListener('click', () => {
            document.getElementById('flaggedPanel').style.display = 'none';
        });

        document.getElementById('flaggedFilter').addEventListener('change', applyFlaggedFilters);
        document.getElementById('flaggedSort').addEventListener('change', applyFlaggedFilters);
        document.getElementById('refreshFlagged').addEventListener('click', loadFlaggedExamples);

        // Close panel with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('flaggedPanel').style.display === 'flex') {
                document.getElementById('flaggedPanel').style.display = 'none';
            }
        });

        // Load flagged count periodically
        setInterval(async () => {
            try {
                const response = await fetch('/api/flagged_examples?t=' + Date.now());
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('flaggedCount').textContent = data.total;
                }
            } catch (error) {
                // Silently fail
            }
        }, 10000); // Every 10 seconds

        console.log('‚úÖ Flagged examples panel initialized');
    </script>

    <!-- Load modular JS files (REFACTORED) -->
    <script src="/monitoring/js/monitor_metrics.js"></script>
    <script src="/monitoring/js/monitor_charts.js"></script>
    <script src="/monitoring/js/monitor_improvements.js"></script>
    <!-- Queue Preview Panel (Bottom, Fixed) -->
    <div id="queuePreviewPanel" style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(15, 23, 42, 0.98); border-top: 2px solid #00d9ff; max-height: 300px; overflow-y: auto; z-index: 100; display: none;">
        <div style="padding: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #00d9ff; font-size: 1.1em;">üìã Queue Preview - Random Samples</h3>
                <button id="closeQueuePreview" style="padding: 5px 12px; background: rgba(255, 68, 68, 0.2); border: 1px solid #ff4444; color: #ff4444; border-radius: 5px; cursor: pointer;">‚úï Close</button>
            </div>
            <div id="queueSamplesContainer" style="display: flex; gap: 15px; overflow-x: auto; padding: 10px 0;">
                <!-- Samples will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Toggle button for queue preview -->
    <button id="toggleQueuePreview" style="position: fixed; bottom: 10px; right: 10px; padding: 10px 15px; background: rgba(0, 217, 255, 0.2); border: 2px solid #00d9ff; color: #00d9ff; border-radius: 8px; cursor: pointer; font-size: 0.9em; z-index: 99; display: none;">
        üëÅÔ∏è Preview Queue
    </button>

</body>
</html>
