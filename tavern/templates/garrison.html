<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garrison | Realm of Training</title>
    <link rel="stylesheet" href="/static/css/theme.css?v=1">
    <link rel="stylesheet" href="/static/css/game.css?v=7">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        .garrison-page {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        body {
            padding-bottom: 80px;
        }

        .host-count {
            font-size: 0.8em;
            color: #666;
            font-family: 'Inter', sans-serif;
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-sm:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.4);
        }

        .header-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Locations Summary */
        .locations-summary {
            margin-bottom: 20px;
        }

        .locations-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .location-card {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
            transition: all 0.2s;
        }

        .location-card:hover {
            border-color: rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }

        .location-card.online {
            border-color: rgba(34, 197, 94, 0.4);
            background: rgba(34, 197, 94, 0.1);
        }

        .location-card.offline {
            border-color: rgba(100, 100, 100, 0.3);
            opacity: 0.6;
        }

        .location-card.warning {
            border-color: rgba(255, 167, 38, 0.4);
            background: rgba(255, 167, 38, 0.1);
        }

        .location-icon {
            font-size: 2rem;
        }

        .location-info {
            display: flex;
            flex-direction: column;
        }

        .location-name {
            font-weight: 600;
            color: #fff;
            font-size: 1rem;
        }

        .location-status {
            font-size: 0.8rem;
            color: #888;
        }

        .location-status.online {
            color: #4CAF50;
        }

        .location-status.offline {
            color: #666;
        }

        .location-stats {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
        }

        /* Status banner */
        .status-banner {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 16px 24px;
            border-radius: 12px;
            margin-bottom: 24px;
            font-size: 1.1rem;
        }

        .status-healthy {
            background: linear-gradient(135deg, #1a3a1a 0%, #0d2a0d 100%);
            border: 2px solid #4CAF50;
        }
        .status-warning {
            background: linear-gradient(135deg, #3a3a1a 0%, #2a2a0d 100%);
            border: 2px solid #ffa726;
        }
        .status-critical {
            background: linear-gradient(135deg, #3a1a1a 0%, #2a0d0d 100%);
            border: 2px solid #f44336;
        }
        .status-unknown, .status-offline {
            background: #252538;
            border: 2px solid #666;
        }

        .status-icon {
            font-size: 2rem;
        }

        /* Zones summary */
        .zones-summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .zone-card {
            background: #252538;
            border-radius: 8px;
            padding: 16px;
            border-left: 4px solid;
        }

        .zone-card.hot { border-left-color: #f44336; }
        .zone-card.warm { border-left-color: #ffa726; }
        .zone-card.cold { border-left-color: #2196F3; }

        .zone-name {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .zone-percent {
            font-size: 1.8rem;
            font-weight: 600;
        }

        .zone-detail {
            font-size: 0.85rem;
            color: #666;
            margin-top: 4px;
        }

        /* Host grid */
        .hosts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .host-card {
            background: #252538;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #333;
            position: relative;
        }

        /* Role-based styling */
        .host-card.role-trainer {
            border-top: 3px solid #ffd700;
        }
        .host-card.role-inference {
            border-top: 3px solid #9c27b0;
        }
        .host-card.role-storage {
            border-top: 3px solid #2196F3;
        }
        .host-card.role-worker {
            border-top: 3px solid #4CAF50;
        }

        .host-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .host-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }

        .host-ip {
            color: #888;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .host-roles {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .role-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            background: #333;
            color: #aaa;
        }

        .role-badge.trainer { background: #3d3d00; color: #ffd700; }
        .role-badge.inference { background: #2d1a3d; color: #ce93d8; }
        .role-badge.eval_worker { background: #1a3d1a; color: #a5d6a7; }
        .role-badge.data_forge { background: #3d2a1a; color: #ffcc80; }
        .role-badge.storage_warm { background: #1a2a3d; color: #90caf9; }
        .role-badge.storage_cold { background: #1a1a3d; color: #9fa8da; }

        .host-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .host-status.healthy { background: #1b5e20; color: #a5d6a7; }
        .host-status.warning { background: #e65100; color: #ffcc80; }
        .host-status.critical { background: #b71c1c; color: #ef9a9a; }
        .host-status.unknown { background: #424242; color: #bdbdbd; }
        .host-status.offline { background: #37474f; color: #90a4ae; }

        /* Metrics grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .metric-box {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
        }

        .metric-box.wide {
            grid-column: span 2;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 600;
            color: #fff;
        }

        .metric-value.warning { color: #ffa726; }
        .metric-value.critical { color: #f44336; }
        .metric-value.good { color: #4CAF50; }

        .metric-detail {
            font-size: 0.8rem;
            color: #666;
            margin-top: 2px;
        }

        /* Progress bars */
        .progress-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-fill.good { background: #4CAF50; }
        .progress-fill.warning { background: #ffa726; }
        .progress-fill.critical { background: #f44336; }

        /* Volumes section (for NAS) */
        .volumes-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #333;
        }

        .volumes-title {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .volume-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 0.85rem;
        }

        .volume-path {
            color: #aaa;
        }

        .volume-stats {
            color: #666;
        }

        /* Services list */
        .services-section {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #333;
        }

        .services-title {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        .services-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .service-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .service-badge.up { background: #1b5e20; color: #a5d6a7; }
        .service-badge.down { background: #b71c1c; color: #ef9a9a; }
        .service-badge.error { background: #e65100; color: #ffcc80; }

        /* Issues list */
        .issues-section {
            margin-top: 12px;
        }

        .issue-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: #3a2a1a;
            border-radius: 4px;
            font-size: 0.85rem;
            color: #ffcc80;
            margin-bottom: 6px;
        }

        /* RAID status */
        .raid-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .raid-status.healthy { background: #1b5e20; color: #a5d6a7; }
        .raid-status.degraded { background: #b71c1c; color: #ef9a9a; }

        /* Uptime */
        .uptime {
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
        }

        /* Last updated */
        .last-updated {
            text-align: center;
            color: #666;
            font-size: 0.85rem;
            margin-top: 20px;
        }

        /* Action buttons */
        .actions {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
        }

        .btn-secondary {
            background: #424242;
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: #616161;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid #333;
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Alerts section */
        .alerts-section {
            background: #2a1a1a;
            border: 1px solid #5a2a2a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .alerts-title {
            color: #f44336;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .alert-item {
            padding: 8px 12px;
            background: #3a1a1a;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #ffcdd2;
        }

        .alert-item:last-child {
            margin-bottom: 0;
        }

        /* Host count badges */
        .host-count {
            background: #333;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            color: #888;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <!-- TITLE BAR -->
    <header class="game-header">
        <div class="header-left">
            <h1 class="game-title">üõ°Ô∏è Garrison</h1>
        </div>
        <div class="header-center">
            <div class="resource-bar">
                <div class="resource">
                    <span class="resource-icon">üñ•Ô∏è</span>
                    <span class="resource-label">HOSTS</span>
                    <span class="resource-value" id="hostCount">0</span>
                </div>
                <div class="resource">
                    <span class="resource-icon" id="statusIcon">‚ö™</span>
                    <span class="resource-label">STATUS</span>
                    <span class="resource-value" id="statusText">--</span>
                </div>
            </div>
        </div>
        <div class="header-right">
            <button class="btn btn-sm" onclick="refreshStatus()" title="Load cached status (fast, updates every few minutes)">üîÑ</button>
            <button class="btn btn-sm" onclick="refreshStatus(true)" title="Scan all hosts now (slower, but always current)">üì°</button>
            <button class="btn btn-sm" onclick="runMaintenance()" title="Run cleanup tasks on all hosts">üîß</button>
        </div>
    </header>

    <div class="garrison-page">
        <div id="status-banner" class="status-banner status-unknown">
            <span class="status-icon">?</span>
            <span>Loading fleet status...</span>
        </div>

        <!-- Locations Summary -->
        <div class="locations-summary" id="locationsSummary">
            <div class="locations-grid" id="locationsGrid">
                <!-- Populated by JS -->
            </div>
        </div>

        <div id="alerts-container"></div>

        <div id="zones-container" class="zones-summary" style="display: none;"></div>

        <div id="hosts-container" class="hosts-grid">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading fleet health...</p>
            </div>
        </div>

        <div id="last-updated" class="last-updated"></div>
    </div>

    <!-- Bottom Navigation -->
    <nav id="bottomNav"></nav>
    <script src="/static/js/nav.js"></script>

    <script>
        let statusData = null;

        function getStatusClass(status) {
            return status || 'unknown';
        }

        function getProgressClass(percent) {
            if (percent >= 90) return 'critical';
            if (percent >= 80) return 'warning';
            return 'good';
        }

        function formatBytes(mb) {
            if (mb >= 1024) return (mb / 1024).toFixed(1) + ' GB';
            return mb.toFixed(0) + ' MB';
        }

        function getRoleClass(host) {
            const roles = host.roles || [];
            if (roles.includes('trainer') || roles.includes('control_plane')) return 'role-trainer';
            if (roles.includes('inference')) return 'role-inference';
            if (roles.includes('storage_warm') || roles.includes('storage_cold')) return 'role-storage';
            if (roles.includes('eval_worker') || roles.includes('data_forge')) return 'role-worker';
            return '';
        }

        // Location definitions with icons
        const LOCATIONS = {
            'trainer': { icon: 'üíª', name: 'Trainer', desc: 'RTX 4090 Training Server' },
            'inference': { icon: 'üîÆ', name: 'Inference', desc: 'RTX 3090 Inference Server' },
            'synology': { icon: 'üì¶', name: 'Synology NAS', desc: 'Network Storage (Warm)' },
            'cold_storage': { icon: 'üßä', name: 'Cold Storage', desc: 'Archive Storage' },
            'vault': { icon: 'üóùÔ∏è', name: 'Vault', desc: 'Asset Registry' },
            'oracle': { icon: 'üîÆ', name: 'Oracle', desc: 'Inference Endpoint' },
            'forge': { icon: 'üî•', name: 'Forge', desc: 'Data Generation' },
            'guild': { icon: 'üè∞', name: 'Guild', desc: 'Skill Management' },
        };

        function renderLocations(hosts) {
            const container = document.getElementById('locationsGrid');
            if (!container) return;

            // Build location cards from hosts data
            let html = '';

            // Define all locations we want to show
            const locationDefs = [
                { id: 'trainer4090', icon: 'üíª', name: 'Trainer (4090)', hostKey: 'trainer4090' },
                { id: 'inference3090', icon: 'üîÆ', name: 'Inference (3090)', hostKey: 'inference3090' },
                { id: 'synology_data', icon: 'üì¶', name: 'Synology NAS', hostKey: 'synology_data' },
                { id: 'vault', icon: 'üóùÔ∏è', name: 'Vault', service: true, port: 8767 },
                { id: 'oracle', icon: 'üîÆ', name: 'Oracle', service: true, port: 8765 },
                { id: 'tavern', icon: 'üè∞', name: 'Tavern', service: true, port: 8888 },
            ];

            for (const loc of locationDefs) {
                let status = 'offline';
                let statusText = 'Offline';
                let statsText = '';

                // Check if this is a host-based location
                if (loc.hostKey && hosts) {
                    // Direct match by hostKey
                    const host = hosts[loc.hostKey];
                    if (host) {
                        status = host.status || 'unknown';
                        statusText = status.charAt(0).toUpperCase() + status.slice(1);

                        // Build stats
                        const stats = [];
                        if (host.disk_percent != null) {
                            stats.push(`Disk: ${host.disk_percent.toFixed(0)}%`);
                        }
                        if (host.gpu_memory_percent != null) {
                            stats.push(`GPU: ${host.gpu_memory_percent.toFixed(0)}%`);
                        }
                        if (host.services?.checkpoints != null) {
                            stats.push(`${host.services.checkpoints} ckpts`);
                        }
                        statsText = stats.join(' ¬∑ ');
                    }
                }

                // Service-based locations - assume online for now
                if (loc.service) {
                    status = 'online';
                    statusText = `Port ${loc.port}`;
                }

                html += `
                    <div class="location-card ${status}">
                        <span class="location-icon">${loc.icon}</span>
                        <div class="location-info">
                            <span class="location-name">${loc.name}</span>
                            <span class="location-status ${status}">${statusText}</span>
                            ${statsText ? `<span class="location-stats">${statsText}</span>` : ''}
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function renderZones(zones) {
            const container = document.getElementById('zones-container');
            if (!zones || Object.keys(zones).length === 0) {
                container.style.display = 'none';
                return;
            }

            let hasData = false;
            let html = '';

            for (const [zoneName, stats] of Object.entries(zones)) {
                if (stats.total_gb > 0) {
                    hasData = true;
                    const percentClass = getProgressClass(stats.percent);
                    html += `
                        <div class="zone-card ${zoneName}">
                            <div class="zone-name">${zoneName} Zone</div>
                            <div class="zone-percent ${percentClass}">${stats.percent.toFixed(1)}%</div>
                            <div class="zone-detail">${stats.used_gb.toFixed(0)} GB / ${stats.total_gb.toFixed(0)} GB</div>
                            <div class="zone-detail">${stats.devices.length} device(s)</div>
                            <div class="progress-bar">
                                <div class="progress-fill ${percentClass}" style="width: ${stats.percent}%"></div>
                            </div>
                        </div>
                    `;
                }
            }

            if (hasData) {
                container.innerHTML = html;
                container.style.display = 'grid';
            } else {
                container.style.display = 'none';
            }
        }

        function renderAlerts(alerts) {
            const container = document.getElementById('alerts-container');
            if (!alerts || alerts.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = `
                <div class="alerts-section">
                    <div class="alerts-title">Alerts (${alerts.length})</div>
            `;

            for (const alert of alerts) {
                html += `<div class="alert-item">${alert}</div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function renderHost(hostId, host) {
            const status = host.status || 'unknown';
            const name = host.name || hostId;
            const roleClass = getRoleClass(host);

            let html = `
                <div class="host-card ${roleClass}">
                    <div class="host-header">
                        <div>
                            <div class="host-name">${name}</div>
                            <div class="host-ip">${host.host}</div>
            `;

            // Role badges
            if (host.roles && host.roles.length > 0) {
                html += '<div class="host-roles">';
                for (const role of host.roles.slice(0, 4)) {
                    html += `<span class="role-badge ${role}">${role.replace('_', ' ')}</span>`;
                }
                if (host.roles.length > 4) {
                    html += `<span class="role-badge">+${host.roles.length - 4}</span>`;
                }
                html += '</div>';
            }

            html += `
                        </div>
                        <span class="host-status ${status}">${status.toUpperCase()}</span>
                    </div>

                    <div class="metrics-grid">
            `;

            // Disk
            if (host.disk_percent !== null && host.disk_percent !== undefined) {
                const diskClass = getProgressClass(host.disk_percent);
                html += `
                    <div class="metric-box">
                        <div class="metric-label">Disk</div>
                        <div class="metric-value ${diskClass}">${host.disk_percent.toFixed(0)}%</div>
                        <div class="metric-detail">${host.disk_free_gb?.toFixed(0) || '?'}GB free / ${host.disk_total_gb?.toFixed(0) || '?'}GB</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${diskClass}" style="width: ${host.disk_percent}%"></div>
                        </div>
                    </div>
                `;
            }

            // RAM
            if (host.ram_percent !== null && host.ram_percent !== undefined) {
                const ramClass = getProgressClass(host.ram_percent);
                html += `
                    <div class="metric-box">
                        <div class="metric-label">RAM</div>
                        <div class="metric-value ${ramClass}">${host.ram_percent.toFixed(0)}%</div>
                        <div class="metric-detail">${host.ram_used_gb?.toFixed(0) || '?'}GB / ${host.ram_total_gb?.toFixed(0) || '?'}GB</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${ramClass}" style="width: ${host.ram_percent}%"></div>
                        </div>
                    </div>
                `;
            }

            // Load Average (for CPU workers)
            if (host.load_avg_1m !== null && host.load_avg_1m !== undefined) {
                const cores = host.cpu_cores || 1;
                const loadPercent = (host.load_avg_1m / cores) * 100;
                const loadClass = loadPercent >= 100 ? 'critical' : loadPercent >= 80 ? 'warning' : 'good';
                html += `
                    <div class="metric-box">
                        <div class="metric-label">Load (1/5/15m)</div>
                        <div class="metric-value ${loadClass}">${host.load_avg_1m.toFixed(2)}</div>
                        <div class="metric-detail">${host.load_avg_5m?.toFixed(2) || '?'} / ${host.load_avg_15m?.toFixed(2) || '?'}${host.cpu_cores ? ' (' + host.cpu_cores + ' cores)' : ''}</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${loadClass}" style="width: ${Math.min(loadPercent, 100)}%"></div>
                        </div>
                    </div>
                `;
            }

            // GPU Memory
            if (host.gpu_memory_percent !== null && host.gpu_memory_percent !== undefined) {
                const gpuClass = getProgressClass(host.gpu_memory_percent);
                let gpuDetail = `${formatBytes(host.gpu_memory_used_mb || 0)} / ${formatBytes(host.gpu_memory_total_mb || 0)}`;
                if (host.gpu_utilization !== null && host.gpu_utilization !== undefined) {
                    gpuDetail += ` (${host.gpu_utilization.toFixed(0)}% util)`;
                }
                html += `
                    <div class="metric-box">
                        <div class="metric-label">GPU Memory</div>
                        <div class="metric-value ${gpuClass}">${host.gpu_memory_percent.toFixed(0)}%</div>
                        <div class="metric-detail">${gpuDetail}</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${gpuClass}" style="width: ${host.gpu_memory_percent}%"></div>
                        </div>
                    </div>
                `;
            }

            // GPU Temp
            if (host.gpu_temp_c !== null && host.gpu_temp_c !== undefined) {
                const tempClass = host.gpu_temp_c >= 80 ? 'critical' : host.gpu_temp_c >= 70 ? 'warning' : 'good';
                let tempDetail = host.gpu_name || 'GPU';
                if (host.gpu_power_watts) {
                    tempDetail += ` (${host.gpu_power_watts.toFixed(0)}W)`;
                }
                html += `
                    <div class="metric-box">
                        <div class="metric-label">GPU Temp</div>
                        <div class="metric-value ${tempClass}">${host.gpu_temp_c.toFixed(0)}¬∞C</div>
                        <div class="metric-detail">${tempDetail}</div>
                    </div>
                `;
            }

            // CPU Temp (if available and no GPU)
            if (host.cpu_temp_c !== null && host.cpu_temp_c !== undefined && host.gpu_temp_c === null) {
                const tempClass = host.cpu_temp_c >= 80 ? 'critical' : host.cpu_temp_c >= 70 ? 'warning' : 'good';
                html += `
                    <div class="metric-box">
                        <div class="metric-label">CPU Temp</div>
                        <div class="metric-value ${tempClass}">${host.cpu_temp_c.toFixed(0)}¬∞C</div>
                    </div>
                `;
            }

            html += `</div>`; // Close metrics-grid

            // Volumes (for NAS)
            if (host.volumes && host.volumes.length > 0) {
                html += `
                    <div class="volumes-section">
                        <div class="volumes-title">Volumes</div>
                `;
                for (const vol of host.volumes) {
                    const volClass = getProgressClass(vol.percent);
                    html += `
                        <div class="volume-item">
                            <span class="volume-path">${vol.path}</span>
                            <span class="volume-stats ${volClass}">${vol.percent.toFixed(0)}% (${vol.free_gb.toFixed(0)}GB free)</span>
                        </div>
                        <div class="progress-bar" style="margin-top: 4px; margin-bottom: 8px;">
                            <div class="progress-fill ${volClass}" style="width: ${vol.percent}%"></div>
                        </div>
                    `;
                }
                html += '</div>';
            }

            // RAID status
            if (host.raid_status) {
                const raidClass = host.raid_status === 'HEALTHY' ? 'healthy' : 'degraded';
                html += `
                    <div style="margin-top: 12px;">
                        <span class="raid-status ${raidClass}">RAID: ${host.raid_status}</span>
                    </div>
                `;
            }

            // Services
            const services = host.services || {};
            const serviceKeys = Object.keys(services).filter(k => k !== 'name' && k !== 'checkpoints');
            if (serviceKeys.length > 0 || services.checkpoints !== undefined) {
                html += `
                    <div class="services-section">
                        <div class="services-title">Services</div>
                        <div class="services-list">
                `;

                for (const key of serviceKeys) {
                    const value = services[key];
                    const badgeClass = value === 'up' ? 'up' : value === 'down' ? 'down' : 'error';
                    html += `<span class="service-badge ${badgeClass}">${key}: ${value}</span>`;
                }

                if (services.checkpoints !== undefined) {
                    html += `<span class="service-badge up">checkpoints: ${services.checkpoints}</span>`;
                }

                html += `</div></div>`;
            }

            // Issues
            if (host.issues && host.issues.length > 0) {
                html += `<div class="issues-section">`;
                for (const issue of host.issues) {
                    html += `<div class="issue-item">&#9888; ${issue}</div>`;
                }
                html += `</div>`;
            }

            // Uptime
            if (host.uptime) {
                html += `<div class="uptime">Uptime: ${host.uptime}</div>`;
            }

            html += `</div>`; // Close host-card
            return html;
        }

        function renderStatus(data) {
            statusData = data;

            // Update header stats
            const hostCount = Object.keys(data.hosts || {}).length;
            const hostCountEl = document.getElementById('hostCount');
            if (hostCountEl) hostCountEl.textContent = hostCount;

            const status = data.overall_status || 'unknown';
            const statusIcons = { healthy: 'üü¢', warning: 'üü°', critical: 'üî¥', unknown: '‚ö™', offline: '‚ö´' };
            const statusIconEl = document.getElementById('statusIcon');
            const statusTextEl = document.getElementById('statusText');
            if (statusIconEl) statusIconEl.textContent = statusIcons[status] || '‚ö™';
            if (statusTextEl) statusTextEl.textContent = status.toUpperCase();

            // Update banner
            const banner = document.getElementById('status-banner');
            const bannerIcons = { healthy: '&#10003;', warning: '&#9888;', critical: '&#10007;', unknown: '?', offline: '&#9675;' };
            if (banner) {
                banner.className = `status-banner status-${status}`;
                banner.innerHTML = `
                    <span class="status-icon">${bannerIcons[status] || '?'}</span>
                    <span>Fleet Status: ${status.toUpperCase()}</span>
                `;
            }

            // Render alerts
            renderAlerts(data.alerts);

            // Render locations summary
            renderLocations(data.hosts || {});

            // Render zones
            renderZones(data.zones);

            // Render hosts (sorted by role priority)
            const container = document.getElementById('hosts-container');
            let html = '';

            // Sort hosts: trainer > inference > storage > workers
            const sortedHosts = Object.entries(data.hosts || {}).sort(([, a], [, b]) => {
                const priority = (host) => {
                    const roles = host.roles || [];
                    if (roles.includes('trainer') || roles.includes('control_plane')) return 0;
                    if (roles.includes('inference')) return 1;
                    if (roles.includes('storage_warm') || roles.includes('storage_cold')) return 2;
                    return 3;
                };
                return priority(a) - priority(b);
            });

            for (const [hostId, host] of sortedHosts) {
                html += renderHost(hostId, host);
            }

            if (container) container.innerHTML = html || '<p>No hosts found</p>';

            // Update timestamp with cache info
            const lastUpdated = document.getElementById('last-updated');
            if (lastUpdated) {
                let timeText = `Last updated: ${new Date(data.timestamp).toLocaleString()}`;
                if (data._cached) {
                    const ageMin = Math.floor(data._cache_age_seconds / 60);
                    const ageSec = Math.floor(data._cache_age_seconds % 60);
                    timeText += ` (cached ${ageMin}m ${ageSec}s ago)`;
                } else {
                    timeText += ' (live)';
                }
                lastUpdated.textContent = timeText;
            }
        }

        async function refreshStatus(forceFresh = false) {
            const container = document.getElementById('hosts-container');
            try {
                const loadingMsg = forceFresh ? 'Scanning fleet...' : 'Refreshing...';
                if (container) {
                    container.innerHTML = `<div class="loading"><div class="spinner"></div><p>${loadingMsg}</p></div>`;
                }

                const url = forceFresh ? '/api/garrison?fresh=true' : '/api/garrison';
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                renderStatus(data);
            } catch (error) {
                console.error('Failed to fetch status:', error);
                if (container) {
                    container.innerHTML =
                        `<p style="color: #f44336;">Failed to load fleet status: ${error.message}</p>`;
                }
            }
        }

        async function runMaintenance() {
            if (!confirm('Run maintenance tasks? This will clean up old checkpoints.')) {
                return;
            }

            try {
                const response = await fetch('/api/garrison/maintenance');
                const data = await response.json();

                if (data.success) {
                    const actions = data.actions.length > 0
                        ? data.actions.join('\n')
                        : 'No maintenance needed';
                    alert('Maintenance complete:\n\n' + actions);
                    refreshStatus();
                } else {
                    alert('Maintenance failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to run maintenance: ' + error.message);
            }
        }

        // Initial load
        refreshStatus();

        // Auto-refresh every 30 seconds
        setInterval(refreshStatus, 30000);
    </script>
</body>
</html>
